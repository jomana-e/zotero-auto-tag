"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ManagerTool = exports.BasicTool = void 0;
exports.unregister = unregister;
exports.makeHelperTool = makeHelperTool;
const toolkitGlobal_1 = __importDefault(require("./managers/toolkitGlobal"));
/**
 * Basic APIs with Zotero 6 & newer (7) compatibility.
 * See also https://www.zotero.org/support/dev/zotero_7_for_developers
 */
class BasicTool {
    get basicOptions() {
        return this._basicOptions;
    }
    /**
     *
     * @param basicTool Pass an BasicTool instance to copy its options.
     */
    constructor(data) {
        /**
         * @deprecated Use `patcherManager` instead.
         */
        this.patchSign = "zotero-plugin-toolkit@2.0.0";
        this._basicOptions = {
            log: {
                _type: "toolkitlog",
                disableConsole: false,
                disableZLog: false,
                prefix: "",
            },
            debug: toolkitGlobal_1.default.getInstance().debugBridge,
            api: {
                pluginID: "zotero-plugin-toolkit@windingwind.com",
            },
            listeners: {
                callbacks: {
                    onMainWindowLoad: new Set(),
                    onMainWindowUnload: new Set(),
                    onPluginUnload: new Set(),
                },
                _mainWindow: undefined,
                _plugin: undefined,
            },
        };
        this.updateOptions(data);
        return;
    }
    getGlobal(k) {
        const _Zotero = typeof Zotero !== "undefined"
            ? Zotero
            : // @ts-ignore
                Components.classes["@zotero.org/Zotero;1"].getService(Components.interfaces.nsISupports).wrappedJSObject;
        try {
            const window = _Zotero.getMainWindow();
            switch (k) {
                case "Zotero":
                case "zotero":
                    return _Zotero;
                case "window":
                    return window;
                case "windows":
                    return _Zotero.getMainWindows();
                case "document":
                    return window.document;
                case "ZoteroPane":
                case "ZoteroPane_Local":
                    return _Zotero.getActiveZoteroPane();
                default:
                    return window[k];
            }
        }
        catch (e) {
            Zotero.logError(e);
        }
    }
    /**
     * Check if it's running on Zotero 7 (Firefox 102)
     */
    isZotero7() {
        return Zotero.platformMajorVersion >= 102;
    }
    isFX115() {
        return Zotero.platformMajorVersion >= 115;
    }
    /**
     * Get DOMParser.
     *
     * For Zotero 6: mainWindow.DOMParser or nsIDOMParser
     *
     * For Zotero 7: Firefox 102 support DOMParser natively
     */
    getDOMParser() {
        if (this.isZotero7()) {
            return new (this.getGlobal("DOMParser"))();
        }
        try {
            return new (this.getGlobal("DOMParser"))();
        }
        catch (e) {
            // @ts-ignore
            return Components.classes["@mozilla.org/xmlextras/domparser;1"
            // @ts-ignore
            ].createInstance(Components.interfaces.nsIDOMParser);
        }
    }
    /**
     * If it's an XUL element
     * @param elem
     */
    isXULElement(elem) {
        return (elem.namespaceURI ===
            "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul");
    }
    /**
     * Create an XUL element
     *
     * For Zotero 6, use `createElementNS`;
     *
     * For Zotero 7+, use `createXULElement`.
     * @param doc
     * @param type
     * @example
     * Create a `<menuitem>`:
     * ```ts
     * const compat = new ZoteroCompat();
     * const doc = compat.getWindow().document;
     * const elem = compat.createXULElement(doc, "menuitem");
     * ```
     */
    createXULElement(doc, type) {
        if (this.isZotero7()) {
            // @ts-ignore
            return doc.createXULElement(type);
        }
        else {
            return doc.createElementNS("http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul", type);
        }
    }
    /**
     * Output to both Zotero.debug and console.log
     * @param data e.g. string, number, object, ...
     */
    log(...data) {
        var _a;
        if (data.length === 0) {
            return;
        }
        const Zotero = this.getGlobal("Zotero");
        const console = this.getGlobal("console");
        // If logOption is not provides, use the global one.
        let options;
        if (((_a = data[data.length - 1]) === null || _a === void 0 ? void 0 : _a._type) === "toolkitlog") {
            options = data.pop();
        }
        else {
            options = this._basicOptions.log;
        }
        try {
            if (options.prefix) {
                data.splice(0, 0, options.prefix);
            }
            if (!options.disableConsole) {
                console.groupCollapsed(...data);
                console.trace();
                console.groupEnd();
            }
            if (!options.disableZLog) {
                Zotero.debug(data
                    .map((d) => {
                    try {
                        return typeof d === "object" ? JSON.stringify(d) : String(d);
                    }
                    catch (e) {
                        Zotero.debug(d);
                        return "";
                    }
                })
                    .join("\n"));
            }
        }
        catch (e) {
            console.error(e);
            Zotero.logError(e);
        }
    }
    /**
     * Patch a function
     * @deprecated Use {@link PatchHelper} instead.
     * @param object The owner of the function
     * @param funcSign The signature of the function(function name)
     * @param ownerSign The signature of patch owner to avoid patching again
     * @param patcher The new wrapper of the patched function
     */
    patch(object, funcSign, ownerSign, patcher) {
        if (object[funcSign][ownerSign]) {
            throw new Error(`${String(funcSign)} re-patched`);
        }
        this.log("patching", funcSign, `by ${ownerSign}`);
        object[funcSign] = patcher(object[funcSign]);
        object[funcSign][ownerSign] = true;
    }
    /**
     * Add a Zotero event listener callback
     * @param type Event type
     * @param callback Event callback
     */
    addListenerCallback(type, callback) {
        if (["onMainWindowLoad", "onMainWindowUnload"].includes(type)) {
            this._ensureMainWindowListener();
        }
        if (type === "onPluginUnload") {
            this._ensurePluginListener();
        }
        this._basicOptions.listeners.callbacks[type].add(callback);
    }
    /**
     * Remove a Zotero event listener callback
     * @param type Event type
     * @param callback Event callback
     */
    removeListenerCallback(type, callback) {
        this._basicOptions.listeners.callbacks[type].delete(callback);
        // Remove listener if no callback
        this._ensureRemoveListener();
    }
    /**
     * Remove all Zotero event listener callbacks when the last callback is removed.
     */
    _ensureRemoveListener() {
        const { listeners } = this._basicOptions;
        if (listeners._mainWindow &&
            listeners.callbacks.onMainWindowLoad.size === 0 &&
            listeners.callbacks.onMainWindowUnload.size === 0) {
            Services.wm.removeListener(listeners._mainWindow);
            delete listeners._mainWindow;
        }
        if (listeners._plugin && listeners.callbacks.onPluginUnload.size === 0) {
            Zotero.Plugins.removeObserver(listeners._plugin);
            delete listeners._plugin;
        }
    }
    /**
     * Ensure the main window listener is registered.
     */
    _ensureMainWindowListener() {
        if (this._basicOptions.listeners._mainWindow) {
            return;
        }
        const mainWindowListener = {
            onOpenWindow: (xulWindow) => {
                // @ts-ignore
                const domWindow = xulWindow.docShell.domWindow;
                const onload = async () => {
                    domWindow.removeEventListener("load", onload, false);
                    if (domWindow.location.href !==
                        "chrome://zotero/content/zoteroPane.xhtml") {
                        return;
                    }
                    for (const cbk of this._basicOptions.listeners.callbacks
                        .onMainWindowLoad) {
                        try {
                            cbk(domWindow);
                        }
                        catch (e) {
                            this.log(e);
                        }
                    }
                };
                domWindow.addEventListener("load", () => onload(), false);
            },
            onCloseWindow: async (xulWindow) => {
                // @ts-ignore
                const domWindow = xulWindow.docShell.domWindow;
                if (domWindow.location.href !== "chrome://zotero/content/zoteroPane.xhtml") {
                    return;
                }
                for (const cbk of this._basicOptions.listeners.callbacks
                    .onMainWindowUnload) {
                    try {
                        cbk(domWindow);
                    }
                    catch (e) {
                        this.log(e);
                    }
                }
            },
        };
        this._basicOptions.listeners._mainWindow = mainWindowListener;
        Services.wm.addListener(mainWindowListener);
    }
    /**
     * Ensure the plugin listener is registered.
     */
    _ensurePluginListener() {
        if (this._basicOptions.listeners._plugin) {
            return;
        }
        const pluginListener = {
            shutdown: (...args) => {
                for (const cbk of this._basicOptions.listeners.callbacks
                    .onPluginUnload) {
                    try {
                        cbk(...args);
                    }
                    catch (e) {
                        this.log(e);
                    }
                }
            },
        };
        this._basicOptions.listeners._plugin = pluginListener;
        Zotero.Plugins.addObserver(pluginListener);
    }
    updateOptions(source) {
        if (!source) {
            return this;
        }
        if (source instanceof BasicTool) {
            this._basicOptions = source._basicOptions;
        }
        else {
            this._basicOptions = source;
        }
        return this;
    }
    static getZotero() {
        return typeof Zotero !== "undefined"
            ? Zotero
            : // @ts-ignore
                Components.classes["@zotero.org/Zotero;1"].getService(Components.interfaces.nsISupports).wrappedJSObject;
    }
}
exports.BasicTool = BasicTool;
class ManagerTool extends BasicTool {
    _ensureAutoUnregisterAll() {
        this.addListenerCallback("onPluginUnload", (params, reason) => {
            if (params.id !== this.basicOptions.api.pluginID) {
                return;
            }
            this.unregisterAll();
        });
    }
}
exports.ManagerTool = ManagerTool;
function unregister(tools) {
    Object.values(tools).forEach((tool) => {
        if (tool instanceof ManagerTool ||
            typeof (tool === null || tool === void 0 ? void 0 : tool.unregisterAll) === "function") {
            tool.unregisterAll();
        }
    });
}
function makeHelperTool(cls, options) {
    return new Proxy(cls, {
        construct(target, args) {
            const _origin = new cls(...args);
            if (_origin instanceof BasicTool) {
                _origin.updateOptions(options);
            }
            return _origin;
        },
    });
}
//# sourceMappingURL=basic.js.map