"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PluginBridge = void 0;
const basic_1 = require("../basic");
/**
 * Plugin bridge. Install plugin from zotero://plugin
 * @example
 * Install plugin from url, with minimal Zotero version requirement.
 * ```text
 * zotero://plugin/?action=install&url=https%3A%2F%2Fgithub.com%2FMuiseDestiny%2Fzotero-style%2Freleases%2Fdownload%2F3.0.5%2Fzotero-style.xpi&minVersion=6.999
 * ```
 */
class PluginBridge {
    get version() {
        return PluginBridge.version;
    }
    constructor() {
        this.initializePluginBridge();
    }
    static setModule(instance) {
        var _a;
        if (!((_a = instance.pluginBridge) === null || _a === void 0 ? void 0 : _a.version) ||
            instance.pluginBridge.version < PluginBridge.version) {
            instance.pluginBridge = new PluginBridge();
        }
    }
    initializePluginBridge() {
        // @ts-ignore
        const { AddonManager } = ChromeUtils.import("resource://gre/modules/AddonManager.jsm");
        const Zotero = basic_1.BasicTool.getZotero();
        const pluginBridgeExtension = {
            noContent: true,
            doAction: async (uri) => {
                var _a;
                try {
                    const uriString = uri.spec.split("//").pop();
                    if (!uriString) {
                        return;
                    }
                    const params = {};
                    (_a = uriString
                        .split("?")
                        .pop()) === null || _a === void 0 ? void 0 : _a.split("&").forEach((p) => {
                        params[p.split("=")[0]] = decodeURIComponent(p.split("=")[1]);
                    });
                    if (params.action === "install" && params.url) {
                        if ((params.minVersion &&
                            Services.vc.compare(Zotero.version, params.minVersion) < 0) ||
                            (params.maxVersion &&
                                Services.vc.compare(Zotero.version, params.maxVersion) > 0)) {
                            throw new Error(`Plugin is not compatible with Zotero version ${Zotero.version}.` +
                                `The plugin requires Zotero version between ${params.minVersion} and ${params.maxVersion}.`);
                        }
                        const addon = await AddonManager.getInstallForURL(params.url);
                        if (addon && addon.state === AddonManager.STATE_AVAILABLE) {
                            addon.install();
                            hint("Plugin installed successfully.", true);
                        }
                        else {
                            throw new Error(`Plugin ${params.url} is not available.`);
                        }
                    }
                }
                catch (e) {
                    Zotero.logError(e);
                    hint(e.message, false);
                }
            },
            newChannel: function (uri) {
                this.doAction(uri);
            },
        };
        // @ts-ignore
        Services.io.getProtocolHandler("zotero").wrappedJSObject._extensions["zotero://plugin"] = pluginBridgeExtension;
    }
}
exports.PluginBridge = PluginBridge;
PluginBridge.version = 1;
function hint(content, success) {
    const progressWindow = new Zotero.ProgressWindow({ closeOnClick: true });
    progressWindow.changeHeadline("Plugin Toolkit");
    // @ts-ignore
    progressWindow.progress = new progressWindow.ItemProgress(success
        ? "chrome://zotero/skin/tick.png"
        : "chrome://zotero/skin/cross.png", content);
    // @ts-ignore
    progressWindow.progress.setProgress(100);
    progressWindow.show();
    progressWindow.startCloseTimer(5000);
}
//# sourceMappingURL=pluginBridge.js.map