"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ItemTreeManager = void 0;
const basic_1 = require("../basic");
const fieldHook_1 = require("./fieldHook");
const toolkitGlobal_1 = __importDefault(require("./toolkitGlobal"));
const patch_1 = require("./patch");
/**
 * Register customized new columns to the library itemTree.
 * @deprecated Use `Zotero.ItemTreeManager.registerColumns` instead.
 */
class ItemTreeManager extends basic_1.ManagerTool {
    /**
     * Initialize Zotero._ItemTreeExtraColumnsGlobal if it doesn't exist.
     *
     * New columns and hooks are stored there.
     *
     * Then patch `require("zotero/itemTree").getColumns` and `Zotero.Item.getField`
     */
    constructor(base) {
        super(base);
        this.defaultPersist = [
            "width",
            "ordinal",
            "hidden",
            "sortActive",
            "sortDirection",
        ];
        this.backend = this.getGlobal("Zotero").ItemTreeManager;
        // TODO: remove these two caches
        this.localColumnCache = [];
        this.localRenderCellCache = [];
        this.fieldHooks = new fieldHook_1.FieldHookManager(base);
        this.patcherManager = new patch_1.PatcherManager(base);
        this.initializationLock = this.getGlobal("Zotero").Promise.defer();
        if (!this.backend) {
            this.initializeGlobal();
        }
        else {
            this.initializationLock.resolve();
        }
    }
    unregisterAll() {
        // Skip field hook unregister and use fieldHooks.unregisterAll
        // to unregister those created by this manager only
        [...this.localColumnCache].forEach((key) => this.unregister(key, { skipGetField: true }));
        [...this.localRenderCellCache].forEach(this.removeRenderCellHook.bind(this));
        this.fieldHooks.unregisterAll();
    }
    /**
     * Register a new column. Don't forget to call `unregister` on plugin exit.
     * @param key Column dataKey
     * @param label Column display label
     * @param getFieldHook Called when loading cell content.
     * If you registered the getField hook somewhere else (in ItemBox or FieldHooks), leave it undefined.
     * @param options See zotero source code:chrome/content/zotero/itemTreeColumns.jsx
     * @param options.renderCellHook Called when rendering cell. This will override
     *
     * @example
     * ```ts
     * const itemTree = new ItemTreeTool();
     * await itemTree.register(
     *   "test",
     *   "new column",
     *   (
     *     field: string,
     *     unformatted: boolean,
     *     includeBaseMapped: boolean,
     *     item: Zotero.Item
     *   ) => {
     *     return field + String(item.id);
     *   },
     *   {
     *     iconPath: "chrome://zotero/skin/cross.png",
     *   }
     * );
     * ```
     */
    async register(key, label, getFieldHook, options = {
        showInColumnPicker: true,
    }) {
        var _a;
        await ((_a = this.initializationLock) === null || _a === void 0 ? void 0 : _a.promise);
        if (!this.backend) {
            if (this.globalCache.columns
                .map((_c) => _c.dataKey)
                .includes(key)) {
                this.log(`ItemTreeTool: ${key} is already registered.`);
                return;
            }
        }
        const column = {
            dataKey: key,
            label: label,
            pluginID: this._basicOptions.api.pluginID,
            iconLabel: options.iconPath
                ? this.createIconLabel({
                    iconPath: options.iconPath,
                    name: label,
                })
                : undefined,
            iconPath: options.iconPath,
            htmlLabel: options.htmlLabel,
            zoteroPersist: options.zoteroPersist ||
                (this.backend ? this.defaultPersist : new Set(this.defaultPersist)),
            defaultIn: options.defaultIn,
            disabledIn: options.disabledIn,
            enabledTreeIDs: options.enabledTreeIDs,
            defaultSort: options.defaultSort,
            sortReverse: options.sortReverse || options.defaultSort === -1,
            flex: typeof options.flex === "undefined" ? 1 : options.flex,
            width: options.width,
            fixedWidth: options.fixedWidth,
            staticWidth: options.staticWidth,
            minWidth: options.minWidth,
            ignoreInColumnPicker: options.ignoreInColumnPicker,
            showInColumnPicker: typeof options.ignoreInColumnPicker === "undefined"
                ? true
                : options.showInColumnPicker,
            submenu: options.submenu,
            columnPickerSubMenu: options.columnPickerSubMenu || options.submenu,
            dataProvider: options.dataProvider ||
                ((item, _dataKey) => item.getField(key)),
            renderCell: options.renderCell ||
                options.renderCellHook,
        };
        if (getFieldHook) {
            this.fieldHooks.register("getField", key, getFieldHook);
        }
        if (this.backend) {
            return await this.backend.registerColumns(column);
        }
        else {
            this.globalCache.columns.push(column);
            this.localColumnCache.push(column.dataKey);
            if (options.renderCellHook) {
                await this.addRenderCellHook(key, options.renderCellHook);
            }
            await this.refresh();
        }
    }
    /**
     * Unregister an extra column. Call it on plugin exit.
     * @param key Column dataKey, should be same as the one used in `register`
     * @param options.skipGetField skip unregister of getField hook.
     * This is useful when the hook is not initialized by this instance
     */
    async unregister(key, options = {}) {
        await this.initializationLock.promise;
        if (this.backend) {
            await this.backend.unregisterColumns(key);
            if (!options.skipGetField) {
                this.fieldHooks.unregister("getField", key);
            }
            return;
        }
        const Zotero = this.getGlobal("Zotero");
        let persisted = Zotero.Prefs.get("pane.persist");
        const persistedJSON = JSON.parse(persisted);
        delete persistedJSON[key];
        Zotero.Prefs.set("pane.persist", JSON.stringify(persistedJSON));
        const idx = this.globalCache.columns.map((_c) => _c.dataKey).indexOf(key);
        if (idx >= 0) {
            this.globalCache.columns.splice(idx, 1);
        }
        if (!options.skipGetField) {
            this.fieldHooks.unregister("getField", key);
        }
        this.removeRenderCellHook(key);
        await this.refresh();
        const localKeyIdx = this.localColumnCache.indexOf(key);
        if (localKeyIdx >= 0) {
            this.localColumnCache.splice(localKeyIdx, 1);
        }
    }
    /**
     * Add a patch hook for `_renderCell`, which is called when cell is rendered.
     * @deprecated
     *
     * This also works for Zotero's built-in cells.
     * @remarks
     * Don't call it manually unless you understand what you are doing.
     * @param dataKey Cell `dataKey`, e.g. 'title'
     * @param renderCellHook patch hook
     */
    async addRenderCellHook(dataKey, renderCellHook) {
        await this.initializationLock.promise;
        if (dataKey in this.globalCache.renderCellHooks) {
            this.log("[WARNING] ItemTreeTool.addRenderCellHook overwrites an existing hook:", dataKey);
        }
        this.globalCache.renderCellHooks[dataKey] = renderCellHook;
        this.localRenderCellCache.push(dataKey);
    }
    /**
     * Remove a patch hook by `dataKey`.
     * @deprecated
     */
    async removeRenderCellHook(dataKey) {
        delete this.globalCache.renderCellHooks[dataKey];
        const idx = this.localRenderCellCache.indexOf(dataKey);
        if (idx >= 0) {
            this.localRenderCellCache.splice(idx, 1);
        }
        await this.refresh();
    }
    /**
     * Do initializations. Called in constructor to be async
     */
    async initializeGlobal() {
        const Zotero = this.getGlobal("Zotero");
        await Zotero.uiReadyPromise;
        const window = this.getGlobal("window");
        this.globalCache = toolkitGlobal_1.default.getInstance().itemTree;
        const globalCache = this.globalCache;
        if (!globalCache._ready) {
            globalCache._ready = true;
            // @ts-ignore
            const itemTree = window.require("zotero/itemTree");
            if (!this.backend) {
                this.patcherManager.register(itemTree.prototype, "getColumns", (original) => function () {
                    // @ts-ignore
                    const columns = original.apply(this, arguments);
                    const insertAfter = columns.findIndex((column) => column.dataKey === "title");
                    columns.splice(insertAfter + 1, 0, ...globalCache.columns);
                    return columns;
                });
            }
            this.patcherManager.register(itemTree.prototype, "_renderCell", (original) => function (index, data, column) {
                if (!(column.dataKey in globalCache.renderCellHooks)) {
                    // @ts-ignore
                    return original.apply(this, arguments);
                }
                const hook = globalCache.renderCellHooks[column.dataKey];
                // @ts-ignore
                const elem = hook(index, data, column, original.bind(this));
                if (elem.classList.contains("cell")) {
                    return elem;
                }
                const span = window.document.createElementNS("http://www.w3.org/1999/xhtml", "span");
                span.classList.add("cell", column.dataKey, `${column.dataKey}-item-tree-main-default`);
                if (column.fixedWidth) {
                    span.classList.add("fixed-width");
                }
                span.appendChild(elem);
                return span;
            });
        }
        this.initializationLock.resolve();
    }
    /**
     * Create a React Icon element
     * @param props
     */
    createIconLabel(props) {
        // @ts-ignore
        const _React = window.require("react");
        return _React.createElement("span", null, _React.createElement("img", {
            src: props.iconPath,
            height: "10px",
            width: "9px",
            style: {
                "margin-left": "6px",
            },
        }), " ", props.name);
    }
    /**
     * Refresh itemView. You don't need to call it manually.
     */
    async refresh() {
        var _a, _b;
        await this.initializationLock.promise;
        const ZoteroPane = this.getGlobal("ZoteroPane");
        const itemsView = ZoteroPane.itemsView;
        if (!itemsView)
            return;
        itemsView._columnsId = null;
        const virtualizedTable = (_a = itemsView.tree) === null || _a === void 0 ? void 0 : _a._columns;
        if (!virtualizedTable) {
            this.log("ItemTree is still loading. Refresh skipped.");
            return;
        }
        // Remove style list otherwise the change will not be updated
        (_b = document.querySelector(`.${virtualizedTable._styleKey}`)) === null || _b === void 0 ? void 0 : _b.remove();
        // Refresh to rebuild _columns
        await itemsView.refreshAndMaintainSelection();
        // Construct a new virtualized-table, otherwise it will not be updated
        itemsView.tree._columns = new virtualizedTable.__proto__.constructor(itemsView.tree);
        // Refresh again to totally make the itemView updated
        await itemsView.refreshAndMaintainSelection();
    }
}
exports.ItemTreeManager = ItemTreeManager;
//# sourceMappingURL=itemTree.js.map