"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ShortcutManager = void 0;
const basic_1 = require("../basic");
const ui_1 = require("../tools/ui");
const basic_2 = require("../basic");
const toolkitGlobal_1 = __importDefault(require("./toolkitGlobal"));
/**
 * Register shortcut keys.
 * @deprecated Use { @link KeyboardManager} instead.
 */
class ShortcutManager extends basic_2.ManagerTool {
    constructor(base) {
        super(base);
        this.ui = new ui_1.UITool(this);
        this.creatorId = `${Zotero.Utilities.randomString()}-${new Date().getTime()}`;
        this.initializeGlobal();
    }
    register(type, keyOptions) {
        const _keyOptions = keyOptions;
        _keyOptions.type = type;
        switch (_keyOptions.type) {
            case "event":
                this.registerEventKey(_keyOptions);
                return true;
            case "element":
                this.registerElementKey(_keyOptions);
                return true;
            case "prefs":
                this.getGlobal("Zotero").Prefs.set(_keyOptions.id, _keyOptions.key || "");
                return true;
            default:
                try {
                    if (_keyOptions.register) {
                        return _keyOptions.register(_keyOptions);
                    }
                    else {
                        return false;
                    }
                }
                catch (e) {
                    this.log(e);
                    return false;
                }
        }
    }
    /**
     * Get all shortcuts(element, event, prefs, builtin)
     */
    getAll() {
        return Array.prototype.concat(this.getMainWindowElementKeys(), this.getEventKeys(), this.getPrefsKeys(), this.getBuiltinKeys());
    }
    /**
     * Check key conflicting of `inputKeyOptions`.
     * @param inputKeyOptions
     * @param options
     * @returns conflicting keys array
     */
    checkKeyConflicting(inputKeyOptions, options = { includeEmpty: false, customKeys: [] }) {
        var _a;
        inputKeyOptions.modifiers = new KeyModifier(inputKeyOptions.modifiers || "").getRaw();
        let allKeys = this.getAll();
        if ((_a = options.customKeys) === null || _a === void 0 ? void 0 : _a.length) {
            allKeys = allKeys.concat(options.customKeys);
        }
        if (!options.includeEmpty) {
            allKeys = allKeys.filter((_keyOptions) => _keyOptions.key);
        }
        return allKeys.filter((_keyOptions) => {
            var _a, _b;
            return _keyOptions.id !== inputKeyOptions.id &&
                ((_a = _keyOptions.key) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === ((_b = inputKeyOptions.key) === null || _b === void 0 ? void 0 : _b.toLowerCase()) &&
                _keyOptions.modifiers === inputKeyOptions.modifiers;
        });
    }
    /**
     * Find all key conflicting.
     * @param options
     * @returns An array of conflicting keys arrays. Same conflicting keys are put together.
     */
    checkAllKeyConflicting(options = { includeEmpty: false, customKeys: [] }) {
        var _a;
        let allKeys = this.getAll();
        if ((_a = options.customKeys) === null || _a === void 0 ? void 0 : _a.length) {
            allKeys = allKeys.concat(options.customKeys);
        }
        if (!options.includeEmpty) {
            allKeys = allKeys.filter((_keyOptions) => _keyOptions.key);
        }
        const conflicting = [];
        while (allKeys.length > 0) {
            const checkKey = allKeys.pop();
            const conflictKeys = allKeys.filter((_keyOptions) => {
                var _a, _b;
                return ((_a = _keyOptions.key) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === ((_b = checkKey.key) === null || _b === void 0 ? void 0 : _b.toLowerCase()) &&
                    _keyOptions.modifiers === checkKey.modifiers;
            });
            if (conflictKeys.length) {
                conflictKeys.push(checkKey);
                conflicting.push(conflictKeys);
                const conflictingKeyIds = conflictKeys.map((key) => key.id);
                // Find index in allKeys
                const toRemoveIds = [];
                allKeys.forEach((key, i) => conflictingKeyIds.includes(key.id) && toRemoveIds.push(i));
                // Sort toRemoveIds in decrease and remove these keys by id
                toRemoveIds
                    .sort((a, b) => b - a)
                    .forEach((id) => allKeys.splice(id, 1));
            }
        }
        return conflicting;
    }
    /**
     * Unregister a key.
     * @remarks
     * `builtin` keys cannot be unregistered.
     * @param keyOptions
     * @returns `true` for success and `false` for failure.
     */
    async unregister(keyOptions) {
        var _a;
        switch (keyOptions.type) {
            case "element":
                (_a = (keyOptions.xulData.document ||
                    this.getGlobal("document"))
                    .querySelector(`#${keyOptions.id}`)) === null || _a === void 0 ? void 0 : _a.remove();
                return true;
            case "prefs":
                this.getGlobal("Zotero").Prefs.set(keyOptions.id, "");
                return true;
            case "builtin":
                return false;
            case "event":
                let idx = this.globalCache.eventKeys.findIndex((currentKey) => currentKey.id === keyOptions.id);
                while (idx >= 0) {
                    this.globalCache.eventKeys.splice(idx, 1);
                    idx = this.globalCache.eventKeys.findIndex((currentKey) => currentKey.id === keyOptions.id);
                }
                return true;
            default:
                try {
                    if (keyOptions.unregister) {
                        return await keyOptions.unregister(keyOptions);
                    }
                    else {
                        return false;
                    }
                }
                catch (e) {
                    this.log(e);
                    return false;
                }
        }
    }
    /**
     * Unregister all keys created by this instance.
     */
    unregisterAll() {
        // Unregister element keys
        this.ui.unregisterAll();
        // Unregister event keys
        this.globalCache.eventKeys
            .filter((keyOptions) => keyOptions.creatorId === this.creatorId)
            .forEach((keyOptions) => this.unregister(keyOptions));
    }
    initializeGlobal() {
        const Zotero = this.getGlobal("Zotero");
        const window = this.getGlobal("window");
        this.globalCache = toolkitGlobal_1.default.getInstance().shortcut;
        if (!this.globalCache._ready) {
            this.globalCache._ready = true;
            window.addEventListener("keypress", (event) => {
                let eventMods = [];
                let eventModsWithAccel = [];
                if (event.altKey) {
                    eventMods.push("alt");
                    eventModsWithAccel.push("alt");
                }
                if (event.shiftKey) {
                    eventMods.push("shift");
                    eventModsWithAccel.push("shift");
                }
                if (event.metaKey) {
                    eventMods.push("meta");
                    Zotero.isMac && eventModsWithAccel.push("accel");
                }
                if (event.ctrlKey) {
                    eventMods.push("control");
                    !Zotero.isMac && eventModsWithAccel.push("accel");
                }
                const eventModStr = new KeyModifier(eventMods.join(",")).getRaw();
                const eventModStrWithAccel = new KeyModifier(eventMods.join(",")).getRaw();
                this.globalCache.eventKeys.forEach((keyOptions) => {
                    var _a;
                    if (keyOptions.disabled) {
                        return;
                    }
                    const modStr = new KeyModifier(keyOptions.modifiers || "").getRaw();
                    if ((modStr === eventModStr || modStr === eventModStrWithAccel) &&
                        ((_a = keyOptions.key) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === event.key.toLowerCase()) {
                        keyOptions.callback();
                    }
                });
            });
        }
    }
    registerEventKey(keyOptions) {
        keyOptions.creatorId = this.creatorId;
        this.globalCache.eventKeys.push(keyOptions);
    }
    /**
     * Register Element \<commandset\>. In general, use `registerElementKey` or `registerKey`.
     * @param commandSetOptions
     */
    registerElementCommandset(commandSetOptions) {
        var _a;
        (_a = commandSetOptions.document.querySelector("window")) === null || _a === void 0 ? void 0 : _a.appendChild(this.ui.createElement(commandSetOptions.document, "commandset", {
            id: commandSetOptions.id,
            skipIfExists: true,
            children: commandSetOptions.commands.map((cmd) => ({
                tag: "command",
                id: cmd.id,
                attributes: {
                    oncommand: cmd.oncommand,
                    disabled: cmd.disabled,
                    label: cmd.label,
                },
            })),
        }));
    }
    /**
     * Register Element \<command\>. In general, use `registerElementKey` or `registerKey`.
     * @param commandOptions
     */
    registerElementCommand(commandOptions) {
        var _a;
        if (commandOptions._parentId) {
            this.registerElementCommandset({
                id: commandOptions._parentId,
                document: commandOptions.document,
                commands: [],
            });
        }
        (_a = commandOptions.document
            .querySelector(`commandset#${commandOptions._parentId}`)) === null || _a === void 0 ? void 0 : _a.appendChild(this.ui.createElement(commandOptions.document, "command", {
            id: commandOptions.id,
            skipIfExists: true,
            attributes: {
                oncommand: commandOptions.oncommand,
                disabled: commandOptions.disabled,
                label: commandOptions.label,
            },
        }));
    }
    /**
     * Register Element \<keyset\>. In general, use `registerElementKey` or `registerKey`.
     * @param keySetOptions
     */
    registerElementKeyset(keySetOptions) {
        var _a;
        (_a = keySetOptions.document.querySelector("window")) === null || _a === void 0 ? void 0 : _a.appendChild(this.ui.createElement(keySetOptions.document, "keyset", {
            id: keySetOptions.id,
            skipIfExists: true,
            children: keySetOptions.keys.map((keyOptions) => ({
                tag: "key",
                id: keyOptions.id,
                attributes: {
                    oncommand: keyOptions.xulData.oncommand || "//",
                    command: keyOptions.xulData.command,
                    modifiers: keyOptions.modifiers,
                    key: this.getXULKey(keyOptions.key),
                    keycode: this.getXULKeyCode(keyOptions.key),
                    disabled: keyOptions.disabled,
                },
            })),
        }));
    }
    /**
     * Register a shortcut key element \<key\>.
     * @remarks
     * Provide `_parentId` to register a \<keyset\>;
     *
     * Provide `_commandOptions` to register a \<command\>;
     *
     * Provide `_parentId` in `_commandOptions` to register a \<commandset\>.
     *
     * See examples for more details.
     * @param keyOptions
     * @example
     */
    registerElementKey(keyOptions) {
        var _a;
        const doc = keyOptions.xulData.document || this.getGlobal("document");
        if (keyOptions.xulData._parentId) {
            this.registerElementKeyset({
                id: keyOptions.xulData._parentId,
                document: doc,
                keys: [],
            });
        }
        (_a = doc.querySelector(`keyset#${keyOptions.xulData._parentId}`)) === null || _a === void 0 ? void 0 : _a.appendChild(this.ui.createElement(doc, "key", {
            id: keyOptions.id,
            skipIfExists: true,
            attributes: {
                oncommand: keyOptions.xulData.oncommand || "//",
                command: keyOptions.xulData.command,
                modifiers: keyOptions.modifiers,
                key: this.getXULKey(keyOptions.key),
                keycode: this.getXULKeyCode(keyOptions.key),
                disabled: keyOptions.disabled,
            },
        }));
        if (keyOptions.xulData._commandOptions) {
            this.registerElementCommand(keyOptions.xulData._commandOptions);
        }
    }
    getXULKey(standardKey) {
        if (standardKey.length === 1) {
            return standardKey;
        }
        return undefined;
    }
    getXULKeyCode(standardKey) {
        const idx = Object.values(XUL_KEYCODE_MAPS).findIndex((value) => value === standardKey);
        if (idx >= 0) {
            return Object.values(XUL_KEYCODE_MAPS)[idx];
        }
        return undefined;
    }
    getStandardKey(XULKey, XULKeyCode) {
        if (XULKeyCode && Object.keys(XUL_KEYCODE_MAPS).includes(XULKeyCode)) {
            return XUL_KEYCODE_MAPS[XULKeyCode];
        }
        else {
            return XULKey;
        }
    }
    /**
     * Get all \<commandset\> details.
     * @param doc
     */
    getElementCommandSets(doc) {
        return Array.from((doc || this.getGlobal("document")).querySelectorAll("commandset")).map((cmdSet) => ({
            id: cmdSet.id,
            commands: Array.from(cmdSet.querySelectorAll("command")).map((cmd) => ({
                id: cmd.id,
                oncommand: cmd.getAttribute("oncommand"),
                disabled: cmd.getAttribute("disabled") === "true",
                label: cmd.getAttribute("label"),
                _parentId: cmdSet.id,
            })),
        }));
    }
    /**
     * Get all \<command\> details.
     * @param doc
     */
    getElementCommands(doc) {
        return Array.prototype.concat(...this.getElementCommandSets(doc).map((cmdSet) => cmdSet.commands));
    }
    /**
     * Get all \<keyset\> details.
     * @param doc
     * @param options
     */
    getElementKeySets(doc) {
        let allCommends = this.getElementCommands(doc);
        return Array.from((doc || this.getGlobal("document")).querySelectorAll("keyset")).map((keysetElem) => ({
            id: keysetElem.id,
            document: doc,
            keys: Array.from(keysetElem.querySelectorAll("key")).map((keyElem) => {
                const oncommand = keyElem.getAttribute("oncommand") || "";
                const commandId = keyElem.getAttribute("command") || "";
                const commandOptions = allCommends.find((cmd) => cmd.id === commandId);
                const key = {
                    type: "element",
                    id: keyElem.id,
                    key: this.getStandardKey(keyElem.getAttribute("key") || "", keyElem.getAttribute("keycode") || ""),
                    modifiers: new KeyModifier(keyElem.getAttribute("modifiers") || "").getRaw(),
                    disabled: keyElem.getAttribute("disabled") === "true",
                    xulData: {
                        document: doc,
                        oncommand: oncommand,
                        command: commandId,
                        _parentId: keysetElem.id,
                        _commandOptions: commandOptions,
                    },
                    callback: () => {
                        const win = doc.ownerGlobal;
                        const _eval = win.eval;
                        _eval(oncommand);
                        _eval((commandOptions === null || commandOptions === void 0 ? void 0 : commandOptions.oncommand) || "");
                    },
                };
                return key;
            }),
        }));
    }
    /**
     * Get all \<key\> details.
     * @param doc
     * @param options
     */
    getElementKeys(doc) {
        return Array.prototype
            .concat(...this.getElementKeySets(doc).map((keyset) => keyset.keys))
            .filter((elemKey) => !ELEM_KEY_IGNORE.includes(elemKey.id));
    }
    /**
     * Get \<key\> details in main window.
     * @param options
     */
    getMainWindowElementKeys() {
        return this.getElementKeys(this.getGlobal("document"));
    }
    getEventKeys() {
        return this.globalCache.eventKeys;
    }
    /**
     * Get Zotero builtin keys defined in preferences.
     */
    getPrefsKeys() {
        const Zotero = this.getGlobal("Zotero");
        return PREF_KEYS.map((pref) => ({
            id: pref.id,
            modifiers: pref.modifiers,
            key: Zotero.Prefs.get(pref.id),
            callback: pref.callback,
            type: "prefs",
        }));
    }
    /**
     * Get Zotero builtin keys not defined in preferences.
     */
    getBuiltinKeys() {
        return BUILTIN_KEYS.map((builtin) => ({
            id: builtin.id,
            modifiers: builtin.modifiers,
            key: builtin.key,
            callback: builtin.callback,
            type: "builtin",
        }));
    }
}
exports.ShortcutManager = ShortcutManager;
class KeyModifier {
    constructor(raw) {
        raw = raw || "";
        this.accel = raw.includes("accel");
        this.shift = raw.includes("shift");
        this.control = raw.includes("control");
        this.meta = raw.includes("meta");
        this.alt = raw.includes("alt");
    }
    equals(newMod) {
        this.accel === newMod.accel;
        this.shift === newMod.shift;
        this.control === newMod.control;
        this.meta === newMod.meta;
        this.alt === newMod.alt;
    }
    getRaw() {
        const enabled = [];
        this.accel && enabled.push("accel");
        this.shift && enabled.push("shift");
        this.control && enabled.push("control");
        this.meta && enabled.push("meta");
        this.alt && enabled.push("alt");
        return enabled.join(",");
    }
}
var XUL_KEYCODE_MAPS;
(function (XUL_KEYCODE_MAPS) {
    XUL_KEYCODE_MAPS["VK_CANCEL"] = "Unidentified";
    XUL_KEYCODE_MAPS["VK_BACK"] = "Backspace";
    XUL_KEYCODE_MAPS["VK_TAB"] = "Tab";
    XUL_KEYCODE_MAPS["VK_CLEAR"] = "Clear";
    XUL_KEYCODE_MAPS["VK_RETURN"] = "Enter";
    XUL_KEYCODE_MAPS["VK_ENTER"] = "Enter";
    XUL_KEYCODE_MAPS["VK_SHIFT"] = "Shift";
    XUL_KEYCODE_MAPS["VK_CONTROL"] = "Control";
    XUL_KEYCODE_MAPS["VK_ALT"] = "Alt";
    XUL_KEYCODE_MAPS["VK_PAUSE"] = "Pause";
    XUL_KEYCODE_MAPS["VK_CAPS_LOCK"] = "CapsLock";
    XUL_KEYCODE_MAPS["VK_ESCAPE"] = "Escape";
    XUL_KEYCODE_MAPS["VK_SPACE"] = " ";
    XUL_KEYCODE_MAPS["VK_PAGE_UP"] = "PageUp";
    XUL_KEYCODE_MAPS["VK_PAGE_DOWN"] = "PageDown";
    XUL_KEYCODE_MAPS["VK_END"] = "End";
    XUL_KEYCODE_MAPS["VK_HOME"] = "Home";
    XUL_KEYCODE_MAPS["VK_LEFT"] = "ArrowLeft";
    XUL_KEYCODE_MAPS["VK_UP"] = "ArrowUp";
    XUL_KEYCODE_MAPS["VK_RIGHT"] = "ArrowRight";
    XUL_KEYCODE_MAPS["VK_DOWN"] = "ArrowDown";
    XUL_KEYCODE_MAPS["VK_PRINTSCREEN"] = "PrintScreen";
    XUL_KEYCODE_MAPS["VK_INSERT"] = "Insert";
    XUL_KEYCODE_MAPS["VK_DELETE"] = "Backspace";
    XUL_KEYCODE_MAPS["VK_0"] = "0";
    XUL_KEYCODE_MAPS["VK_1"] = "1";
    XUL_KEYCODE_MAPS["VK_2"] = "2";
    XUL_KEYCODE_MAPS["VK_3"] = "3";
    XUL_KEYCODE_MAPS["VK_4"] = "4";
    XUL_KEYCODE_MAPS["VK_5"] = "5";
    XUL_KEYCODE_MAPS["VK_6"] = "6";
    XUL_KEYCODE_MAPS["VK_7"] = "7";
    XUL_KEYCODE_MAPS["VK_8"] = "8";
    XUL_KEYCODE_MAPS["VK_9"] = "9";
    XUL_KEYCODE_MAPS["VK_A"] = "A";
    XUL_KEYCODE_MAPS["VK_B"] = "B";
    XUL_KEYCODE_MAPS["VK_C"] = "C";
    XUL_KEYCODE_MAPS["VK_D"] = "D";
    XUL_KEYCODE_MAPS["VK_E"] = "E";
    XUL_KEYCODE_MAPS["VK_F"] = "F";
    XUL_KEYCODE_MAPS["VK_G"] = "G";
    XUL_KEYCODE_MAPS["VK_H"] = "H";
    XUL_KEYCODE_MAPS["VK_I"] = "I";
    XUL_KEYCODE_MAPS["VK_J"] = "J";
    XUL_KEYCODE_MAPS["VK_K"] = "K";
    XUL_KEYCODE_MAPS["VK_L"] = "L";
    XUL_KEYCODE_MAPS["VK_M"] = "M";
    XUL_KEYCODE_MAPS["VK_N"] = "N";
    XUL_KEYCODE_MAPS["VK_O"] = "O";
    XUL_KEYCODE_MAPS["VK_P"] = "P";
    XUL_KEYCODE_MAPS["VK_Q"] = "Q";
    XUL_KEYCODE_MAPS["VK_R"] = "R";
    XUL_KEYCODE_MAPS["VK_S"] = "S";
    XUL_KEYCODE_MAPS["VK_T"] = "T";
    XUL_KEYCODE_MAPS["VK_U"] = "U";
    XUL_KEYCODE_MAPS["VK_V"] = "V";
    XUL_KEYCODE_MAPS["VK_W"] = "W";
    XUL_KEYCODE_MAPS["VK_X"] = "X";
    XUL_KEYCODE_MAPS["VK_Y"] = "Y";
    XUL_KEYCODE_MAPS["VK_Z"] = "Z";
    XUL_KEYCODE_MAPS["VK_SEMICOLON"] = "Unidentified";
    XUL_KEYCODE_MAPS["VK_EQUALS"] = "Unidentified";
    XUL_KEYCODE_MAPS["VK_NUMPAD0"] = "0";
    XUL_KEYCODE_MAPS["VK_NUMPAD1"] = "1";
    XUL_KEYCODE_MAPS["VK_NUMPAD2"] = "2";
    XUL_KEYCODE_MAPS["VK_NUMPAD3"] = "3";
    XUL_KEYCODE_MAPS["VK_NUMPAD4"] = "4";
    XUL_KEYCODE_MAPS["VK_NUMPAD5"] = "5";
    XUL_KEYCODE_MAPS["VK_NUMPAD6"] = "6";
    XUL_KEYCODE_MAPS["VK_NUMPAD7"] = "7";
    XUL_KEYCODE_MAPS["VK_NUMPAD8"] = "8";
    XUL_KEYCODE_MAPS["VK_NUMPAD9"] = "9";
    XUL_KEYCODE_MAPS["VK_MULTIPLY"] = "Multiply";
    XUL_KEYCODE_MAPS["VK_ADD"] = "Add";
    XUL_KEYCODE_MAPS["VK_SEPARATOR"] = "Separator";
    XUL_KEYCODE_MAPS["VK_SUBTRACT"] = "Subtract";
    XUL_KEYCODE_MAPS["VK_DECIMAL"] = "Decimal";
    XUL_KEYCODE_MAPS["VK_DIVIDE"] = "Divide";
    XUL_KEYCODE_MAPS["VK_F1"] = "F1";
    XUL_KEYCODE_MAPS["VK_F2"] = "F2";
    XUL_KEYCODE_MAPS["VK_F3"] = "F3";
    XUL_KEYCODE_MAPS["VK_F4"] = "F4";
    XUL_KEYCODE_MAPS["VK_F5"] = "F5";
    XUL_KEYCODE_MAPS["VK_F6"] = "F6";
    XUL_KEYCODE_MAPS["VK_F7"] = "F7";
    XUL_KEYCODE_MAPS["VK_F8"] = "F8";
    XUL_KEYCODE_MAPS["VK_F9"] = "F9";
    XUL_KEYCODE_MAPS["VK_F10"] = "F10";
    XUL_KEYCODE_MAPS["VK_F11"] = "F11";
    XUL_KEYCODE_MAPS["VK_F12"] = "F12";
    XUL_KEYCODE_MAPS["VK_F13"] = "F13";
    XUL_KEYCODE_MAPS["VK_F14"] = "F14";
    XUL_KEYCODE_MAPS["VK_F15"] = "F15";
    XUL_KEYCODE_MAPS["VK_F16"] = "F16";
    XUL_KEYCODE_MAPS["VK_F17"] = "F17";
    XUL_KEYCODE_MAPS["VK_F18"] = "F18";
    XUL_KEYCODE_MAPS["VK_F19"] = "F19";
    XUL_KEYCODE_MAPS["VK_F20"] = "F20";
    XUL_KEYCODE_MAPS["VK_F21"] = "Soft1";
    XUL_KEYCODE_MAPS["VK_F22"] = "Soft2";
    XUL_KEYCODE_MAPS["VK_F23"] = "Soft3";
    XUL_KEYCODE_MAPS["VK_F24"] = "Soft4";
    XUL_KEYCODE_MAPS["VK_NUM_LOCK"] = "NumLock";
    XUL_KEYCODE_MAPS["VK_SCROLL_LOCK"] = "ScrollLock";
    XUL_KEYCODE_MAPS["VK_COMMA"] = ",";
    XUL_KEYCODE_MAPS["VK_PERIOD"] = ".";
    XUL_KEYCODE_MAPS["VK_SLASH"] = "Divide";
    XUL_KEYCODE_MAPS["VK_BACK_QUOTE"] = "`";
    XUL_KEYCODE_MAPS["VK_OPEN_BRACKET"] = "[";
    XUL_KEYCODE_MAPS["VK_CLOSE_BRACKET"] = "]";
    XUL_KEYCODE_MAPS["VK_QUOTE"] = "\\";
    XUL_KEYCODE_MAPS["VK_HELP"] = "Help";
})(XUL_KEYCODE_MAPS || (XUL_KEYCODE_MAPS = {}));
function getElementKeyCallback(keyId) {
    return function () {
        var _a;
        const win = basic_1.BasicTool.getZotero().getMainWindow();
        const keyElem = win.document.querySelector(`#${keyId}`);
        if (!keyElem) {
            return function () { };
        }
        const _eval = win.eval;
        _eval(keyElem.getAttribute("oncommand") || "//");
        const cmdId = keyElem.getAttribute("command");
        if (!cmdId) {
            return;
        }
        _eval(((_a = win.document.querySelector(`#${cmdId}`)) === null || _a === void 0 ? void 0 : _a.getAttribute("oncommand")) || "//");
    };
}
function getBuiltinEventKeyCallback(eventId) {
    return function () {
        const Zotero = basic_1.BasicTool.getZotero();
        const ZoteroPane = Zotero.getActiveZoteroPane();
        ZoteroPane.handleKeyPress({
            metaKey: true,
            ctrlKey: true,
            shiftKey: true,
            originalTarget: { id: "" },
            preventDefault: () => { },
            key: Zotero.Prefs.get(`extensions.zotero.keys.${eventId}`, true),
        });
    };
}
const ELEM_KEY_IGNORE = ["key_copyCitation", "key_copyBibliography"];
const PREF_KEYS = [
    {
        id: "extensions.zotero.keys.copySelectedItemCitationsToClipboard",
        modifiers: "accel,shift",
        elemId: "key_copyCitation",
        callback: getElementKeyCallback("key_copyCitation"),
    },
    {
        id: "extensions.zotero.keys.copySelectedItemsToClipboard",
        modifiers: "accel,shift",
        elemId: "key_copyBibliography",
        callback: getElementKeyCallback("key_copyBibliography"),
    },
    {
        id: "extensions.zotero.keys.library",
        modifiers: "accel,shift",
        callback: getBuiltinEventKeyCallback("library"),
    },
    {
        id: "extensions.zotero.keys.newItem",
        modifiers: "accel,shift",
        callback: getBuiltinEventKeyCallback("newItem"),
    },
    {
        id: "extensions.zotero.keys.newNote",
        modifiers: "accel,shift",
        callback: getBuiltinEventKeyCallback("newNote"),
    },
    {
        id: "extensions.zotero.keys.quicksearch",
        modifiers: "accel,shift",
        callback: getBuiltinEventKeyCallback("quicksearch"),
    },
    {
        id: "extensions.zotero.keys.saveToZotero",
        modifiers: "accel,shift",
        callback: getBuiltinEventKeyCallback("saveToZotero"),
    },
    {
        id: "extensions.zotero.keys.sync",
        modifiers: "accel,shift",
        callback: getBuiltinEventKeyCallback("sync"),
    },
    {
        id: "extensions.zotero.keys.toggleAllRead",
        modifiers: "accel,shift",
        callback: getBuiltinEventKeyCallback("toggleAllRead"),
    },
    {
        id: "extensions.zotero.keys.toggleRead",
        modifiers: "accel,shift",
        callback: getBuiltinEventKeyCallback("toggleRead"),
    },
];
const BUILTIN_KEYS = [
    {
        id: "showItemCollection",
        modifiers: "",
        key: "Ctrl",
        callback: () => {
            const Zotero = basic_1.BasicTool.getZotero();
            const ZoteroPane = Zotero.getActiveZoteroPane();
            ZoteroPane.handleKeyUp({
                originalTarget: {
                    id: ZoteroPane.itemsView ? ZoteroPane.itemsView.id : "",
                },
                keyCode: Zotero.isWin ? 17 : 18,
            });
        },
    },
    {
        id: "closeSelectedTab",
        modifiers: "accel",
        key: "W",
        callback: () => {
            const ztabs = basic_1.BasicTool.getZotero().getMainWindow()
                .Zotero_Tabs;
            if (ztabs.selectedIndex > 0) {
                ztabs.close("");
            }
        },
    },
    {
        id: "undoCloseTab",
        modifiers: "accel,shift",
        key: "T",
        callback: () => {
            const ztabs = basic_1.BasicTool.getZotero().getMainWindow()
                .Zotero_Tabs;
            ztabs.undoClose();
        },
    },
    {
        id: "selectNextTab",
        modifiers: "control",
        key: "Tab",
        callback: () => {
            const ztabs = basic_1.BasicTool.getZotero().getMainWindow()
                .Zotero_Tabs;
            ztabs.selectPrev();
        },
    },
    {
        id: "selectPreviousTab",
        modifiers: "control,shift",
        key: "Tab",
        callback: () => {
            const ztabs = basic_1.BasicTool.getZotero().getMainWindow()
                .Zotero_Tabs;
            ztabs.selectNext();
        },
    },
    {
        id: "selectTab1",
        modifiers: "accel",
        key: "1",
        callback: () => {
            const ztabs = basic_1.BasicTool.getZotero().getMainWindow()
                .Zotero_Tabs;
            ztabs.jump(0);
        },
    },
    {
        id: "selectTab2",
        modifiers: "accel",
        key: "2",
        callback: () => {
            const ztabs = basic_1.BasicTool.getZotero().getMainWindow()
                .Zotero_Tabs;
            ztabs.jump(1);
        },
    },
    {
        id: "selectTab3",
        modifiers: "accel",
        key: "3",
        callback: () => {
            const ztabs = basic_1.BasicTool.getZotero().getMainWindow()
                .Zotero_Tabs;
            ztabs.jump(2);
        },
    },
    {
        id: "selectTab4",
        modifiers: "accel",
        key: "4",
        callback: () => {
            const ztabs = basic_1.BasicTool.getZotero().getMainWindow()
                .Zotero_Tabs;
            ztabs.jump(3);
        },
    },
    {
        id: "selectTab5",
        modifiers: "accel",
        key: "5",
        callback: () => {
            const ztabs = basic_1.BasicTool.getZotero().getMainWindow()
                .Zotero_Tabs;
            ztabs.jump(4);
        },
    },
    {
        id: "selectTab6",
        modifiers: "accel",
        key: "6",
        callback: () => {
            const ztabs = basic_1.BasicTool.getZotero().getMainWindow()
                .Zotero_Tabs;
            ztabs.jump(5);
        },
    },
    {
        id: "selectTab7",
        modifiers: "accel",
        key: "7",
        callback: () => {
            const ztabs = basic_1.BasicTool.getZotero().getMainWindow()
                .Zotero_Tabs;
            ztabs.jump(6);
        },
    },
    {
        id: "selectTab8",
        modifiers: "accel",
        key: "8",
        callback: () => {
            const ztabs = basic_1.BasicTool.getZotero().getMainWindow()
                .Zotero_Tabs;
            ztabs.jump(7);
        },
    },
    {
        id: "selectTabLast",
        modifiers: "accel",
        key: "9",
        callback: () => {
            const ztabs = basic_1.BasicTool.getZotero().getMainWindow()
                .Zotero_Tabs;
            ztabs.selectLast();
        },
    },
];
//# sourceMappingURL=shortcut.js.map