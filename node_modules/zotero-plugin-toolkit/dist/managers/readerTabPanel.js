"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReaderTabPanelManager = void 0;
const ui_1 = require("../tools/ui");
const reader_1 = require("../tools/reader");
const basic_1 = require("../basic");
/**
 * Register new \<tabpanel\> in reader right-side bar.
 */
class ReaderTabPanelManager extends basic_1.ManagerTool {
    constructor(base) {
        super(base);
        this.ui = new ui_1.UITool(this);
        this.readerTool = new reader_1.ReaderTool(this);
        this.readerTabCache = {
            optionsList: [],
            observer: undefined,
            initializeLock: undefined,
        };
    }
    /**
     * Register a tabpanel for every reader.
     * @remarks
     * Don't forget to call `unregisterReaderTabPanel` on exit.
     * @remarks
     * Every time a tab reader is selected/opened, the hook will be called.
     * @param tabLabel Label of panel tab.
     * @param renderPanelHook Called when panel is ready. Add elements to the panel.
     *
     * The panel might be `undefined` when opening a PDF without parent item.
     *
     * The owner deck is the top container of right-side bar.
     *
     * The readerInstance is the reader of current tabpanel.
     * @param options Other optional parameters.
     * @param options.tabId ID of panel tab. Also used as unregister query. If not set, generate a random one.
     * @param options.panelId ID of panel container (XUL.TabPanel). If not set, generate a random one.
     * @param options.targetIndex Index of the inserted tab. Default the end of tabs.
     * @param options.selectPanel If the panel should be selected immediately.
     * @returns tabId. Use it for unregister.
     * @example
     * Register an extra reader tabpanel into index 1.
     * ```ts
     * const readerTabId = `${config.addonRef}-extra-reader-tab`;
     * this._Addon.toolkit.UI.registerReaderTabPanel(
     *   "test",
     *   (
     *     panel: XUL.Element,
     *     deck: XUL.Deck,
     *     win: Window,
     *     reader: _ZoteroReaderInstance
     *   ) => {
     *     if (!panel) {
     *       this._Addon.toolkit.Tool.log(
     *         "This reader do not have right-side bar. Adding reader tab skipped."
     *       );
     *       return;
     *     }
     *     this._Addon.toolkit.Tool.log(reader);
     *     const elem = this._Addon.toolkit.UI.creatElementsFromJSON(
     *       win.document,
     *       {
     *         tag: "vbox",
     *         id: `${config.addonRef}-${reader._instanceID}-extra-reader-tab-div`,
     *         namespace: "xul",
     *         // This is important! Don't create content for multiple times
     *         ignoreIfExists: true,
     *         subElementOptions: [
     *           {
     *             tag: "h2",
     *             directAttributes: {
     *               innerText: "Hello World!",
     *             },
     *           },
     *           {
     *             tag: "label",
     *             namespace: "xul",
     *             directAttributes: {
     *               value: "This is a reader tab.",
     *             },
     *           },
     *           {
     *             tag: "label",
     *             namespace: "xul",
     *             directAttributes: {
     *               value: `Reader: ${reader._title.slice(0, 20)}`,
     *             },
     *           },
     *           {
     *             tag: "label",
     *             namespace: "xul",
     *             directAttributes: {
     *               value: `itemID: ${reader.itemID}.`,
     *             },
     *           },
     *           {
     *             tag: "button",
     *             directAttributes: {
     *               innerText: "Unregister",
     *             },
     *             listeners: [
     *               {
     *                 type: "click",
     *                 listener: () => {
     *                   this._Addon.toolkit.UI.unregisterReaderTabPanel(
     *                     readerTabId
     *                   );
     *                 },
     *               },
     *             ],
     *           },
     *         ],
     *       }
     *     );
     *     panel.append(elem);
     *   },
     *   {
     *     tabId: readerTabId,
     *   }
     * );
     * ```
     */
    async register(tabLabel, renderPanelHook, options) {
        var _a;
        options = options || {
            tabId: undefined,
            panelId: undefined,
            targetIndex: -1,
            selectPanel: false,
        };
        if (typeof this.readerTabCache.initializeLock === "undefined") {
            await this.initializeReaderTabObserver();
        }
        await ((_a = this.readerTabCache.initializeLock) === null || _a === void 0 ? void 0 : _a.promise);
        const randomId = `${Zotero.Utilities.randomString()}-${new Date().getTime()}`;
        const tabId = options.tabId || `toolkit-readertab-${randomId}`;
        const panelId = options.panelId || `toolkit-readertabpanel-${randomId}`;
        const targetIndex = typeof options.targetIndex === "number" ? options.targetIndex : -1;
        this.readerTabCache.optionsList.push({
            tabId,
            tabLabel,
            panelId,
            renderPanelHook,
            targetIndex,
            selectPanel: options.selectPanel,
        });
        // Try to add tabpanel to current reader immediately
        await this.addReaderTabPanel();
        return tabId;
    }
    /**
     * Unregister the reader tabpanel.
     * @param tabId tab id
     */
    unregister(tabId) {
        var _a;
        const idx = this.readerTabCache.optionsList.findIndex((v) => v.tabId === tabId);
        if (idx >= 0) {
            this.readerTabCache.optionsList.splice(idx, 1);
        }
        if (this.readerTabCache.optionsList.length === 0) {
            (_a = this.readerTabCache.observer) === null || _a === void 0 ? void 0 : _a.disconnect();
            this.readerTabCache = {
                optionsList: [],
                observer: undefined,
                initializeLock: undefined,
            };
        }
        this.removeTabPanel(tabId);
    }
    /**
     * Unregister all library tabpanel.
     */
    unregisterAll() {
        const tabIds = this.readerTabCache.optionsList.map((options) => options.tabId);
        tabIds.forEach(this.unregister.bind(this));
    }
    changeTabPanel(tabId, options) {
        const idx = this.readerTabCache.optionsList.findIndex((v) => v.tabId === tabId);
        if (idx >= 0) {
            Object.assign(this.readerTabCache.optionsList[idx], options);
        }
    }
    removeTabPanel(tabId) {
        const doc = this.getGlobal("document");
        Array.prototype.forEach.call(doc.querySelectorAll(`.toolkit-ui-tabs-${tabId}`), (e) => {
            e.remove();
        });
    }
    async initializeReaderTabObserver() {
        this.readerTabCache.initializeLock =
            this.getGlobal("Zotero").Promise.defer();
        await Promise.all([
            Zotero.initializationPromise,
            Zotero.unlockPromise,
            Zotero.uiReadyPromise,
        ]);
        let lock = Zotero.Promise.defer();
        lock.resolve();
        const observer = await this.readerTool.addReaderTabPanelDeckObserver(async () => {
            await lock.promise;
            lock = Zotero.Promise.defer();
            try {
                this.addReaderTabPanel();
            }
            catch (e) { }
            lock.resolve();
        });
        this.readerTabCache.observer = observer;
        this.readerTabCache.initializeLock.resolve();
    }
    async addReaderTabPanel() {
        var _a, _b;
        const window = this.getGlobal("window");
        const deck = this.readerTool.getReaderTabPanelDeck();
        const reader = await this.readerTool.getReader();
        if (!reader) {
            return;
        }
        // PDF without parent item does not have tabpanel. Create one.
        if (((_a = deck.selectedPanel) === null || _a === void 0 ? void 0 : _a.children[0].tagName) === "vbox") {
            const container = deck.selectedPanel;
            container.innerHTML = "";
            this.ui.appendElement({
                tag: "tabbox",
                classList: ["zotero-view-tabbox"],
                attributes: {
                    flex: "1",
                },
                enableElementRecord: false,
                children: [
                    {
                        tag: "tabs",
                        classList: ["zotero-editpane-tabs"],
                        attributes: {
                            orient: "horizontal",
                        },
                        enableElementRecord: false,
                    },
                    {
                        tag: "tabpanels",
                        classList: ["zotero-view-item"],
                        attributes: {
                            flex: "1",
                        },
                        enableElementRecord: false,
                    },
                ],
            }, container);
        }
        let tabbox = (_b = deck.selectedPanel) === null || _b === void 0 ? void 0 : _b.querySelector("tabbox");
        if (!tabbox) {
            return;
        }
        const tabs = tabbox.querySelector("tabs");
        const tabpanels = tabbox.querySelector("tabpanels");
        this.readerTabCache.optionsList.forEach((options) => {
            const tabId = `${options.tabId}-${reader._instanceID}`;
            const tabClass = `toolkit-ui-tabs-${options.tabId}`;
            if (tabs === null || tabs === void 0 ? void 0 : tabs.querySelector(`.${tabClass}`)) {
                return;
            }
            const tab = this.ui.createElement(window.document, "tab", {
                id: tabId,
                classList: [tabClass],
                attributes: {
                    label: options.tabLabel,
                },
                ignoreIfExists: true,
            });
            const tabpanel = this.ui.createElement(window.document, "tabpanel", {
                id: `${options.panelId}-${reader._instanceID}`,
                classList: [tabClass],
                ignoreIfExists: true,
            });
            if (options.targetIndex >= 0) {
                tabs === null || tabs === void 0 ? void 0 : tabs.querySelectorAll("tab")[options.targetIndex].before(tab);
                tabpanels === null || tabpanels === void 0 ? void 0 : tabpanels.querySelectorAll("tabpanel")[options.targetIndex].before(tabpanel);
                if (tabbox.getAttribute("toolkit-select-fixed") !== "true") {
                    // Tabs after current tab will not be correctly selected
                    // A workaround to manually set selection.
                    tabbox.tabpanels.addEventListener("select", () => {
                        this.getGlobal("setTimeout")(() => {
                            // @ts-ignore
                            tabbox.tabpanels.selectedPanel = tabbox.tabs.getRelatedElement(tabbox === null || tabbox === void 0 ? void 0 : tabbox.tabs.selectedItem);
                        }, 0);
                    });
                    tabbox.setAttribute("toolkit-select-fixed", "true");
                }
            }
            else {
                tabs === null || tabs === void 0 ? void 0 : tabs.appendChild(tab);
                tabpanels === null || tabpanels === void 0 ? void 0 : tabpanels.appendChild(tabpanel);
            }
            if (options.selectPanel) {
                tabbox.selectedTab = tab;
            }
            options.renderPanelHook(tabpanel, deck, window, reader);
        });
    }
}
exports.ReaderTabPanelManager = ReaderTabPanelManager;
//# sourceMappingURL=readerTabPanel.js.map