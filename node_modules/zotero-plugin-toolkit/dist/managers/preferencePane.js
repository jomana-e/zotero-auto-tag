"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PreferencePaneManager = void 0;
const ui_1 = require("../tools/ui");
const basic_1 = require("../basic");
/**
 * Register preference pane from Zotero 7's `xhtml`, for Zotero 6 & 7.
 * @deprecated Use `Zotero.PreferencePanes.register` instead.
 */
class PreferencePaneManager extends basic_1.ManagerTool {
    constructor(base) {
        super(base);
        this.alive = true;
        this.ui = new ui_1.UITool(this);
        this.prefPaneCache = { win: undefined, listeners: {} };
    }
    /**
     * Register a preference pane from an xhtml, for Zotero 6 & 7.
     * @remarks
     * Don't forget to call `unregisterPrefPane` on exit.
     * @remarks
     * options:
     * ```ts
     * export interface PrefPaneOptions {
     *   pluginID: string;
     *   src: string;
     *   id?: string;
     *   parent?: string;
     *   label?: string;
     *   image?: string;
     *   extraDTD?: string[];
     *   scripts?: string[];
     *   defaultXUL?: boolean;
     *   // Only for Zotero 6
     *   onload?: (win: Window) => any;
     * }
     * ```
     *
     * @param options See {@link PrefPaneOptions}
     * @example
     * ```ts
     * const prefsManager = new PreferencePaneManager();
     * function initPrefs() {
     *   const prefOptions = {
     *     pluginID: addonID,
     *     src: rootURI + "chrome/content/preferences.xhtml",
     *     label: "Template",
     *     image: `chrome://${addonRef}/content/icons/favicon.png`,
     *     extraDTD: [`chrome://${addonRef}/locale/overlay.dtd`],
     *     defaultXUL: true
     *   };
     *   prefsManager.register(prefOptions);
     * };
     *
     * function unInitPrefs() {
     *   prefsManager.unregisterAll();
     * };
     * ```
     * // bootstrap.js:startup
     * initPrefs();
     *
     * // bootstrap.js:shutdown
     * unInitPrefs();
     */
    register(options) {
        if (this.isZotero7()) {
            this.getGlobal("Zotero").PreferencePanes.register(options);
            return;
        }
        const _initImportedNodesPostInsert = (container) => {
            var _a;
            const _observerSymbols = new Map();
            const Zotero = this.getGlobal("Zotero");
            const window = container.ownerGlobal;
            let useChecked = (elem) => (elem instanceof window.HTMLInputElement &&
                elem.type == "checkbox") ||
                elem.tagName == "checkbox";
            let syncFromPref = (elem, preference) => {
                let value = Zotero.Prefs.get(preference, true);
                if (useChecked(elem)) {
                    elem.checked = value;
                }
                else {
                    elem.value = value;
                }
                elem.dispatchEvent(new window.Event("syncfrompreference"));
            };
            // We use a single listener function shared between all elements so we can easily detach it later
            let syncToPrefOnModify = (event) => {
                const targetNode = event.currentTarget;
                if (targetNode === null || targetNode === void 0 ? void 0 : targetNode.getAttribute("preference")) {
                    let value = useChecked(targetNode)
                        ? targetNode.checked
                        : targetNode.value;
                    Zotero.Prefs.set(targetNode.getAttribute("preference") || "", value, true);
                    targetNode.dispatchEvent(new window.Event("synctopreference"));
                }
            };
            let attachToPreference = (elem, preference) => {
                Zotero.debug(`Attaching <${elem.tagName}> element to ${preference}`);
                // @ts-ignore
                let symbol = Zotero.Prefs.registerObserver(preference, () => syncFromPref(elem, preference), true);
                _observerSymbols.set(elem, symbol);
            };
            let detachFromPreference = (elem) => {
                if (_observerSymbols.has(elem)) {
                    Zotero.debug(`Detaching <${elem.tagName}> element from preference`);
                    // @ts-ignore
                    Zotero.Prefs.unregisterObserver(this._observerSymbols.get(elem));
                    _observerSymbols.delete(elem);
                }
            };
            // Activate `preference` attributes
            for (let elem of Array.from(container.querySelectorAll("[preference]"))) {
                let preference = elem.getAttribute("preference");
                if (container.querySelector("preferences > preference#" + preference)) {
                    this.log("<preference> is deprecated -- `preference` attribute values should be full preference keys, not <preference> IDs");
                    preference = (_a = container
                        .querySelector("preferences > preference#" + preference)) === null || _a === void 0 ? void 0 : _a.getAttribute("name");
                }
                attachToPreference(elem, preference);
                elem.addEventListener(this.isXULElement(elem) ? "command" : "input", syncToPrefOnModify);
                // Set timeout before populating the value so the pane can add listeners first
                window.setTimeout(() => {
                    syncFromPref(elem, preference);
                });
            }
            new window.MutationObserver((mutations) => {
                for (let mutation of mutations) {
                    if (mutation.type == "attributes") {
                        let target = mutation.target;
                        detachFromPreference(target);
                        if (target.hasAttribute("preference")) {
                            attachToPreference(target, target.getAttribute("preference") || "");
                            target.addEventListener(this.isXULElement(target) ? "command" : "input", syncToPrefOnModify);
                        }
                    }
                    else if (mutation.type == "childList") {
                        for (let node of Array.from(mutation.removedNodes)) {
                            detachFromPreference(node);
                        }
                        for (let node of Array.from(mutation.addedNodes)) {
                            if (node.nodeType == window.Node.ELEMENT_NODE &&
                                node.hasAttribute("preference")) {
                                attachToPreference(node, node.getAttribute("preference") || "");
                                node.addEventListener(this.isXULElement(node) ? "command" : "input", syncToPrefOnModify);
                            }
                        }
                    }
                }
            }).observe(container, {
                childList: true,
                subtree: true,
                attributeFilter: ["preference"],
            });
            // parseXULToFragment() doesn't convert oncommand attributes into actual
            // listeners, so we'll do it here
            for (let elem of Array.from(container.querySelectorAll("[oncommand]"))) {
                elem.oncommand = elem.getAttribute("oncommand");
            }
            for (let child of Array.from(container.children)) {
                child.dispatchEvent(new window.Event("load"));
            }
        };
        const windowListener = {
            onOpenWindow: (xulWindow) => {
                // Avoid multiple tabs when unregister fails
                if (!this.alive) {
                    return;
                }
                const win = xulWindow
                    .QueryInterface(Components.interfaces.nsIInterfaceRequestor)
                    .getInterface(Components.interfaces.nsIDOMWindow);
                win.addEventListener("load", async () => {
                    var _a;
                    if (win.location.href ===
                        "chrome://zotero/content/preferences/preferences.xul") {
                        this.log("registerPrefPane:detected", options);
                        const Zotero = this.getGlobal("Zotero");
                        options.id ||
                            (options.id = `plugin-${Zotero.Utilities.randomString()}-${new Date().getTime()}`);
                        const contentOrXHR = await Zotero.File.getContentsAsync(options.src);
                        const content = typeof contentOrXHR === "string"
                            ? contentOrXHR
                            : contentOrXHR.response;
                        const src = `<prefpane xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul" id="${options.id}" insertafter="zotero-prefpane-advanced" label="${options.label || options.pluginID}" image="${options.image || ""}">
                ${content}
                </prefpane>`;
                        const frag = this.ui.parseXHTMLToFragment(src, options.extraDTD, options.defaultXUL);
                        this.log(frag);
                        const prefWindow = win.document.querySelector("prefwindow");
                        prefWindow.appendChild(frag);
                        const prefPane = win.document.querySelector(`#${options.id}`);
                        // @ts-ignore
                        prefWindow.addPane(prefPane);
                        // Enable scroll. Check if the content does overflow the box later.
                        // @ts-ignore
                        const contentBox = win.document.getAnonymousNodes(win.document.querySelector(`#${options.id}`))[0];
                        contentBox.style.overflowY = "scroll";
                        contentBox.style.height = "440px";
                        // Resize window, otherwise the new prefpane may be placed out of the window
                        // @ts-ignore
                        win.sizeToContent();
                        // Disable scroll if the content does not overflow.
                        if (contentBox.scrollHeight === contentBox.clientHeight) {
                            contentBox.style.overflowY = "hidden";
                        }
                        this.prefPaneCache.win = win;
                        this.prefPaneCache.listeners[options.id] = windowListener;
                        // Binding preferences
                        _initImportedNodesPostInsert(prefPane);
                        if ((_a = options.scripts) === null || _a === void 0 ? void 0 : _a.length) {
                            options.scripts.forEach((script) => Services.scriptloader.loadSubScript(script, win));
                        }
                        if (options.onload) {
                            options.onload(win);
                        }
                    }
                }, false);
            },
            onCloseWindow: () => { },
        };
        Services.wm.addListener(windowListener);
    }
    unregister(id) {
        var _a;
        const idx = Object.keys(this.prefPaneCache.listeners).indexOf(id);
        if (idx < 0) {
            return false;
        }
        const listener = this.prefPaneCache.listeners[id];
        Services.wm.removeListener(listener);
        listener.onOpenWindow = undefined;
        const win = this.prefPaneCache.win;
        if (win && !win.closed) {
            (_a = win.document.querySelector(`#${id}`)) === null || _a === void 0 ? void 0 : _a.remove();
        }
        delete this.prefPaneCache.listeners[id];
        return true;
    }
    /**
     * Unregister all preference panes added with this instance
     *
     * Called on exiting
     */
    unregisterAll() {
        this.alive = false;
        for (const id in this.prefPaneCache.listeners) {
            this.unregister(id);
        }
    }
}
exports.PreferencePaneManager = PreferencePaneManager;
//# sourceMappingURL=preferencePane.js.map