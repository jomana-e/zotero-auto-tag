"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PatcherManager = void 0;
const basic_1 = require("../basic");
/**
 * Manage all monkey patching functions.
 * @deprecated Use {@link PatchHelper} instead.
 */
class PatcherManager extends basic_1.ManagerTool {
    constructor(base) {
        super(base);
        // record wether a patcher is alive or not
        this.patcherIDMap = new Map();
    }
    /**
     * Patch a function
     * @param object The owner of the function
     * @param funcSign The signature of the function(function name)
     * @param patcher A function that returns the new wrapper of the patched function
     * @returns A unique ID of the patcher, which can be used to unregister the patcher
     */
    register(object, funcSign, patcher) {
        const Zotero = this.getGlobal("Zotero");
        const patchIDMap = this.patcherIDMap;
        let id = Zotero.randomString();
        while (patchIDMap.has(id)) {
            id = Zotero.randomString();
        }
        const origin = object[funcSign];
        patchIDMap.set(id, true);
        this.log("patching ", funcSign);
        object[funcSign] = function (...args) {
            if (patchIDMap.get(id))
                try {
                    return patcher(origin).apply(this, args);
                }
                catch (e) {
                    Zotero.logError(e);
                }
            return origin.apply(this, args);
        };
        return id;
    }
    /**
     * Unregister a patcher
     * @param patcherID The ID of the patcher to be unregistered
     */
    unregister(patcherID) {
        this.patcherIDMap.delete(patcherID);
    }
    /**
     * Unregister all patchers
     */
    unregisterAll() {
        this.patcherIDMap.clear();
    }
}
exports.PatcherManager = PatcherManager;
//# sourceMappingURL=patch.js.map