"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DialogHelper = void 0;
const ui_1 = require("../tools/ui");
/**
 * Dialog window helper. A superset of XUL dialog.
 */
class DialogHelper extends ui_1.UITool {
    /**
     * Create a dialog helper with row \* column grids.
     * @param row
     * @param column
     */
    constructor(row, column) {
        super();
        if (row <= 0 || column <= 0) {
            throw Error(`row and column must be positive integers.`);
        }
        this.elementProps = {
            tag: "vbox",
            attributes: { flex: 1 },
            styles: {
                width: "100%",
                height: "100%",
            },
            children: [],
        };
        for (let i = 0; i < Math.max(row, 1); i++) {
            this.elementProps.children.push({
                tag: "hbox",
                attributes: { flex: 1 },
                children: [],
            });
            for (let j = 0; j < Math.max(column, 1); j++) {
                this.elementProps.children[i].children.push({
                    tag: "vbox",
                    attributes: { flex: 1 },
                    children: [],
                });
            }
        }
        this.elementProps.children.push({
            tag: "hbox",
            attributes: { flex: 0, pack: "end" },
            children: [],
        });
        this.dialogData = {};
    }
    /**
     * Add a cell at (row, column). Index starts from 0.
     * @param row
     * @param column
     * @param elementProps Cell element props. See {@link ElementProps}
     * @param cellFlex If the cell is flex. Default true.
     */
    addCell(row, column, elementProps, cellFlex = true) {
        if (row >= this.elementProps.children.length ||
            column >= this.elementProps.children[row].children.length) {
            throw Error(`Cell index (${row}, ${column}) is invalid, maximum (${this.elementProps.children.length}, ${this.elementProps.children[0].children.length})`);
        }
        this.elementProps.children[row].children[column].children = [
            elementProps,
        ];
        this.elementProps.children[row].children[column].attributes.flex =
            cellFlex ? 1 : 0;
        return this;
    }
    /**
     * Add a control button to the bottom of the dialog.
     * @param label Button label
     * @param id Button id.
     * The corresponding id of the last button user clicks before window exit will be set to `dialogData._lastButtonId`.
     * @param options.noClose Don't close window when clicking this button.
     * @param options.callback Callback of button click event.
     */
    addButton(label, id, options = {}) {
        id = id || `${Zotero.Utilities.randomString()}-${new Date().getTime()}`;
        this.elementProps.children[this.elementProps.children.length - 1].children.push({
            tag: "vbox",
            styles: {
                margin: "10px",
            },
            children: [
                {
                    tag: "button",
                    namespace: "html",
                    id,
                    attributes: {
                        type: "button",
                        "data-l10n-id": label,
                    },
                    properties: {
                        innerHTML: label,
                    },
                    listeners: [
                        {
                            type: "click",
                            listener: (e) => {
                                this.dialogData._lastButtonId = id;
                                if (options.callback) {
                                    options.callback(e);
                                }
                                if (!options.noClose) {
                                    this.window.close();
                                }
                            },
                        },
                    ],
                },
            ],
        });
        return this;
    }
    /**
     * Dialog data.
     * @remarks
     * This object is passed to the dialog window.
     *
     * The control button id is in `dialogData._lastButtonId`;
     *
     * The data-binding values are in `dialogData`.
     * ```ts
     * interface DialogData {
     *   [key: string | number | symbol]: any;
     *   loadLock?: _ZoteroTypes.PromiseObject; // resolve after window load (auto-generated)
     *   loadCallback?: Function; // called after window load
     *   unloadLock?: _ZoteroTypes.PromiseObject; // resolve after window unload (auto-generated)
     *   unloadCallback?: Function; // called after window unload
     *   beforeUnloadCallback?: Function; // called before window unload when elements are accessable.
     * }
     * ```
     * @param dialogData
     */
    setDialogData(dialogData) {
        this.dialogData = dialogData;
        return this;
    }
    /**
     * Open the dialog
     * @param title Window title
     * @param windowFeatures.width Ignored if fitContent is `true`.
     * @param windowFeatures.height Ignored if fitContent is `true`.
     * @param windowFeatures.left
     * @param windowFeatures.top
     * @param windowFeatures.centerscreen Open window at the center of screen.
     * @param windowFeatures.resizable If window is resizable.
     * @param windowFeatures.fitContent Resize the window to content size after elements are loaded.
     * @param windowFeatures.noDialogMode Dialog mode window only has a close button. Set `true` to make maximize and minimize button visible.
     * @param windowFeatures.alwaysRaised Is the window always at the top.
     */
    open(title, windowFeatures = {
        centerscreen: true,
        resizable: true,
        fitContent: true,
    }) {
        this.window = openDialog(this, `${Zotero.Utilities.randomString()}-${new Date().getTime()}`, title, this.elementProps, this.dialogData, windowFeatures);
        return this;
    }
}
exports.DialogHelper = DialogHelper;
function openDialog(dialogHelper, targetId, title, elementProps, dialogData, windowFeatures = {
    centerscreen: true,
    resizable: true,
    fitContent: true,
}) {
    var _a, _b, _c;
    const Zotero = dialogHelper.getGlobal("Zotero");
    dialogData = dialogData || {};
    // Make windowfeature string
    if (!dialogData.loadLock) {
        dialogData.loadLock = Zotero.Promise.defer();
    }
    if (!dialogData.unloadLock) {
        dialogData.unloadLock = Zotero.Promise.defer();
    }
    let featureString = `resizable=${windowFeatures.resizable ? "yes" : "no"},`;
    if (windowFeatures.width || windowFeatures.height) {
        featureString += `width=${windowFeatures.width || 100},height=${windowFeatures.height || 100},`;
    }
    if (windowFeatures.left) {
        featureString += `left=${windowFeatures.left},`;
    }
    if (windowFeatures.top) {
        featureString += `top=${windowFeatures.top},`;
    }
    if (windowFeatures.centerscreen) {
        featureString += "centerscreen,";
    }
    if (windowFeatures.noDialogMode) {
        featureString += "dialog=no,";
    }
    if (windowFeatures.alwaysRaised) {
        featureString += "alwaysRaised=yes,";
    }
    // Create window
    const win = dialogHelper.getGlobal("openDialog")("about:blank", targetId || "_blank", featureString, dialogData);
    // After load
    (_a = dialogData.loadLock) === null || _a === void 0 ? void 0 : _a.promise.then(() => {
        // Set title
        win.document.head.appendChild(dialogHelper.createElement(win.document, "title", {
            properties: { innerText: title },
            attributes: { "data-l10n-id": title },
        }));
        let l10nFiles = dialogData.l10nFiles || [];
        if (typeof l10nFiles === "string") {
            l10nFiles = [l10nFiles];
        }
        l10nFiles.forEach((file) => {
            win.document.head.appendChild(dialogHelper.createElement(win.document, "link", {
                properties: {
                    rel: "localization",
                    href: file,
                },
            }));
        });
        // Add style according to Zotero prefs
        // For custom select(menulist) and a link
        dialogHelper.appendElement({
            tag: "fragment",
            children: [
                {
                    tag: "style",
                    properties: {
                        innerHTML: style,
                    },
                },
                {
                    tag: "link",
                    properties: {
                        rel: "stylesheet",
                        href: "chrome://zotero-platform/content/zotero.css",
                    },
                },
            ],
        }, win.document.head);
        replaceElement(elementProps, dialogHelper);
        // Create element
        win.document.body.appendChild(dialogHelper.createElement(win.document, "fragment", {
            children: [elementProps],
        }));
        // Load data-binding
        Array.from(win.document.querySelectorAll("*[data-bind]")).forEach((elem) => {
            const bindKey = elem.getAttribute("data-bind");
            const bindAttr = elem.getAttribute("data-attr");
            const bindProp = elem.getAttribute("data-prop");
            if (bindKey && dialogData && dialogData[bindKey]) {
                if (bindProp) {
                    elem[bindProp] = dialogData[bindKey];
                }
                else {
                    elem.setAttribute(bindAttr || "value", dialogData[bindKey]);
                }
            }
        });
        // Resize window
        if (windowFeatures.fitContent) {
            setTimeout(() => {
                win.sizeToContent();
            }, 300);
        }
        win.focus();
    }).then(() => {
        // Custom load callback
        (dialogData === null || dialogData === void 0 ? void 0 : dialogData.loadCallback) && dialogData.loadCallback();
    });
    dialogData.unloadLock.promise.then(() => {
        // Custom unload callback
        (dialogData === null || dialogData === void 0 ? void 0 : dialogData.unloadCallback) && dialogData.unloadCallback();
    });
    // Wait for window loading to resolve the lock promise
    win.addEventListener("DOMContentLoaded", function onWindowLoad(ev) {
        var _a, _b;
        (_b = (_a = win.arguments[0]) === null || _a === void 0 ? void 0 : _a.loadLock) === null || _b === void 0 ? void 0 : _b.resolve();
        win.removeEventListener("DOMContentLoaded", onWindowLoad, false);
    }, false);
    // Wait for window unload. Use beforeunload to access elements.
    win.addEventListener("beforeunload", function onWindowBeforeUnload(ev) {
        // Update data-binding
        Array.from(win.document.querySelectorAll("*[data-bind]")).forEach((elem) => {
            const dialogData = this.window.arguments[0];
            const bindKey = elem.getAttribute("data-bind");
            const bindAttr = elem.getAttribute("data-attr");
            const bindProp = elem.getAttribute("data-prop");
            if (bindKey && dialogData) {
                if (bindProp) {
                    dialogData[bindKey] = elem[bindProp];
                }
                else {
                    dialogData[bindKey] = elem.getAttribute(bindAttr || "value");
                }
            }
        });
        this.window.removeEventListener("beforeunload", onWindowBeforeUnload, false);
        (dialogData === null || dialogData === void 0 ? void 0 : dialogData.beforeUnloadCallback) && dialogData.beforeUnloadCallback();
    });
    // Wait for window unload to resolve the lock promise
    win.addEventListener("unload", function onWindowUnload(ev) {
        var _a, _b, _c;
        if ((_a = this.window.arguments[0]) === null || _a === void 0 ? void 0 : _a.loadLock.promise.isPending()) {
            return;
        }
        (_c = (_b = this.window.arguments[0]) === null || _b === void 0 ? void 0 : _b.unloadLock) === null || _c === void 0 ? void 0 : _c.resolve();
        this.window.removeEventListener("unload", onWindowUnload, false);
    });
    if (win.document.readyState === "complete") {
        (_c = (_b = win.arguments[0]) === null || _b === void 0 ? void 0 : _b.loadLock) === null || _c === void 0 ? void 0 : _c.resolve();
    }
    return win;
}
function replaceElement(elementProps, uiTool) {
    var _a, _b, _c, _d, _e, _f, _g;
    let checkChildren = true;
    if (elementProps.tag === "select" && uiTool.isZotero7()) {
        checkChildren = false;
        const customSelectProps = {
            tag: "div",
            classList: ["dropdown"],
            listeners: [
                {
                    type: "mouseleave",
                    listener: (ev) => {
                        const select = ev.target.querySelector("select");
                        select === null || select === void 0 ? void 0 : select.blur();
                    },
                },
            ],
            children: [
                Object.assign({}, elementProps, {
                    tag: "select",
                    listeners: [
                        {
                            type: "focus",
                            listener: (ev) => {
                                var _a;
                                const select = ev.target;
                                const dropdown = (_a = select.parentElement) === null || _a === void 0 ? void 0 : _a.querySelector(".dropdown-content");
                                dropdown && (dropdown.style.display = "block");
                                select.setAttribute("focus", "true");
                            },
                        },
                        {
                            type: "blur",
                            listener: (ev) => {
                                var _a;
                                const select = ev.target;
                                const dropdown = (_a = select.parentElement) === null || _a === void 0 ? void 0 : _a.querySelector(".dropdown-content");
                                dropdown && (dropdown.style.display = "none");
                                select.removeAttribute("focus");
                            },
                        },
                    ],
                }),
                {
                    tag: "div",
                    classList: ["dropdown-content"],
                    children: (_a = elementProps.children) === null || _a === void 0 ? void 0 : _a.map((option) => {
                        var _a, _b, _c;
                        return ({
                            tag: "p",
                            attributes: {
                                value: (_a = option.properties) === null || _a === void 0 ? void 0 : _a.value,
                            },
                            properties: {
                                innerHTML: ((_b = option.properties) === null || _b === void 0 ? void 0 : _b.innerHTML) || ((_c = option.properties) === null || _c === void 0 ? void 0 : _c.innerText),
                            },
                            classList: ["dropdown-item"],
                            listeners: [
                                {
                                    type: "click",
                                    listener: (ev) => {
                                        var _a;
                                        const select = (_a = ev.target.parentElement) === null || _a === void 0 ? void 0 : _a.previousElementSibling;
                                        select &&
                                            (select.value =
                                                ev.target.getAttribute("value") || "");
                                        select === null || select === void 0 ? void 0 : select.blur();
                                    },
                                },
                            ],
                        });
                    }),
                },
            ],
        };
        for (const key in elementProps) {
            delete elementProps[key];
        }
        Object.assign(elementProps, customSelectProps);
    }
    else if (elementProps.tag === "a") {
        const href = (((_b = elementProps === null || elementProps === void 0 ? void 0 : elementProps.properties) === null || _b === void 0 ? void 0 : _b.href) || "");
        (_c = elementProps.properties) !== null && _c !== void 0 ? _c : (elementProps.properties = {});
        elementProps.properties.href = "javascript:void(0);";
        (_d = elementProps.attributes) !== null && _d !== void 0 ? _d : (elementProps.attributes = {});
        elementProps.attributes["zotero-href"] = href;
        (_e = elementProps.listeners) !== null && _e !== void 0 ? _e : (elementProps.listeners = []);
        elementProps.listeners.push({
            type: "click",
            listener: (ev) => {
                var _a;
                const href = (_a = ev.target) === null || _a === void 0 ? void 0 : _a.getAttribute("zotero-href");
                href && uiTool.getGlobal("Zotero").launchURL(href);
            },
        });
        (_f = elementProps.classList) !== null && _f !== void 0 ? _f : (elementProps.classList = []);
        elementProps.classList.push("zotero-text-link");
    }
    if (checkChildren) {
        (_g = elementProps.children) === null || _g === void 0 ? void 0 : _g.forEach((child) => replaceElement(child, uiTool));
    }
}
const style = `
.zotero-text-link {
  -moz-user-focus: normal;
  color: -moz-nativehyperlinktext;
  text-decoration: underline;
  border: 1px solid transparent;
  cursor: pointer;
}
.dropdown {
  position: relative;
  display: inline-block;
}
.dropdown-content {
  display: none;
  position: absolute;
  background-color: var(--material-toolbar);
  min-width: 160px;
  box-shadow: 0px 0px 5px 0px rgba(0, 0, 0, 0.5);
  border-radius: 5px;
  padding: 5px 0 5px 0;
  z-index: 999;
}
.dropdown-item {
  margin: 0px;
  padding: 5px 10px 5px 10px;
}
.dropdown-item:hover {
  background-color: var(--fill-quinary);
}
`;
//# sourceMappingURL=dialog.js.map