"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VirtualizedTableHelper = void 0;
const basic_1 = require("../basic");
/**
 * VirtualizedTable helper.
 */
class VirtualizedTableHelper extends basic_1.BasicTool {
    constructor(win) {
        super();
        this.window = win;
        const Zotero = this.getGlobal("Zotero");
        const _require = win.require;
        // Don't actually use any React instance, so that it won't be actually compiled.
        this.React = _require("react");
        this.ReactDOM = _require("react-dom");
        this.VirtualizedTable = _require("components/virtualized-table");
        this.IntlProvider = _require("react-intl").IntlProvider;
        this.props = {
            id: `${Zotero.Utilities.randomString()}-${new Date().getTime()}`,
            getRowCount: () => 0,
        };
        this.localeStrings = Zotero.Intl.strings;
    }
    setProp(...args) {
        if (args.length === 1) {
            Object.assign(this.props, args[0]);
        }
        else if (args.length === 2) {
            this.props[args[0]] = args[1];
        }
        return this;
    }
    /**
     * Set locale strings, which replaces the table header's label if matches. Default it's `Zotero.Intl.strings`
     * @param localeStrings
     */
    setLocale(localeStrings) {
        Object.assign(this.localeStrings, localeStrings);
        return this;
    }
    /**
     * Set container element id that the table will be rendered on.
     * @param id element id
     */
    setContainerId(id) {
        this.containerId = id;
        return this;
    }
    /**
     * Render the table.
     * @param selectId Which row to select after rendering
     * @param onfulfilled callback after successfully rendered
     * @param onrejected callback after rendering with error
     */
    render(selectId, onfulfilled, onrejected) {
        const refreshSelection = () => {
            this.treeInstance.invalidate();
            if (typeof selectId !== "undefined" && selectId >= 0) {
                this.treeInstance.selection.select(selectId);
            }
            else {
                this.treeInstance.selection.clearSelection();
            }
        };
        if (!this.treeInstance) {
            const vtableProps = Object.assign({}, this.props, {
                ref: (ref) => (this.treeInstance = ref),
            });
            if (vtableProps.getRowData && !vtableProps.renderItem) {
                Object.assign(vtableProps, {
                    renderItem: this.VirtualizedTable.makeRowRenderer(vtableProps.getRowData),
                });
            }
            const elem = this.React.createElement(this.IntlProvider, { locale: Zotero.locale, messages: Zotero.Intl.strings }, this.React.createElement(this.VirtualizedTable, vtableProps));
            const container = this.window.document.getElementById(this.containerId);
            new Promise((resolve) => this.ReactDOM.render(elem, container, resolve))
                .then(() => {
                // Fix style manager showing partially blank until scrolled
                this.getGlobal("setTimeout")(() => {
                    refreshSelection();
                });
            })
                .then(onfulfilled, onrejected);
        }
        else {
            refreshSelection();
        }
        return this;
    }
}
exports.VirtualizedTableHelper = VirtualizedTableHelper;
//# sourceMappingURL=virtualizedTable.js.map