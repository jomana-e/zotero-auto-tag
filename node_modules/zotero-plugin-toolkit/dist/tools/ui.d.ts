import { BasicOptions, BasicTool } from "../basic";
/**
 * UI APIs. Create elements and manage them.
 */
export declare class UITool extends BasicTool {
    /**
     * UITool options
     */
    protected _basicOptions: UIOptions;
    get basicOptions(): UIOptions;
    /**
     * Store elements created with this instance
     *
     * @remarks
     * > What is this for?
     *
     * In bootstrap plugins, elements must be manually maintained and removed on exiting.
     *
     * This API does this for you.
     */
    protected elementCache: WeakRef<Element>[];
    constructor(base?: BasicTool | BasicOptions);
    /**
     * Remove all elements created by `createElement`.
     *
     * @remarks
     * > What is this for?
     *
     * In bootstrap plugins, elements must be manually maintained and removed on exiting.
     *
     * This API does this for you.
     */
    unregisterAll(): void;
    /**
     * Create `DocumentFragment`.
     * @param doc
     * @param tagName
     * @param props
     * @example
     * ```ts
     * const frag: DocumentFragment = ui.createElement(
     *   document, "fragment",
     *   {
     *     children:
     *     [
     *       { tag: "h1", properties: { innerText: "Hello World!" } }
     *     ]
     *   }
     * );
     * ```
     */
    createElement(doc: Document, tagName: "fragment", props?: FragmentElementProps): DocumentFragment;
    /**
     * Create `HTMLElement`.
     * @param doc
     * @param tagName
     * @param props See {@link ElementProps }
     * @example
     * ```ts
     * const div: HTMLDivElement = ui.createElement(document, "div");
     * ```
     * @example
     * Attributes(for `elem.setAttribute()`), properties(for `elem.prop=`), listeners, and children.
     * ```ts
     * const div: HTMLDivElement = ui.createElement(
     *   document, "div",
     *   {
     *     id: "hi-div",
     *     skipIfExists: true,
     *     listeners:
     *     [
     *       { type: "click", listener: (e)=>ui.log("Clicked!") }
     *     ],
     *     children:
     *     [
     *       { tag: "h1", properties: { innerText: "Hello World!" } },
     *       { tag: "a", attributes: { href: "https://www.zotero.org" } },
     *     ]
     *   }
     * );
     * ```
     */
    createElement<HTML_TAG extends keyof HTMLElementTagNameMap, T extends HTMLElementTagNameMap[HTML_TAG]>(doc: Document, tagName: HTML_TAG, props?: HTMLElementProps): T;
    /**
     * Create `XUL.Element`.
     * @see ElementProps
     * @param doc
     * @param tagName
     * @param props See {@link ElementProps }
     * @example
     * ```ts
     * const menuitem: XUL.MenuItem = ui.createElement(document, "menuitem", { attributes: { label: "Click Me!" } });
     * ```
     */
    createElement<XUL_TAG extends keyof XULElementTagNameMap, T extends XULElementTagNameMap[XUL_TAG]>(doc: Document, tagName: XUL_TAG, props?: XULElementProps): T;
    /**
     * Create `SVGElement`
     * @param doc
     * @param tagName
     * @param props See {@link ElementProps }
     */
    createElement<SVG_TAG extends keyof SVGElementTagNameMap, T extends SVGElementTagNameMap[SVG_TAG]>(doc: Document, tagName: SVG_TAG, props?: SVGElementProps): T;
    /**
     * Create Element
     * @param doc
     * @param tagName
     * @param props See {@link ElementProps }
     */
    createElement(doc: Document, tagName: string, props?: ElementProps): HTMLElement | XUL.Element | SVGElement;
    /**
     * @deprecated
     * @param doc target document, e.g. Zotero main window.document
     * @param tagName element tag name, e.g. `hbox`, `div`
     * @param namespace default "html"
     * @param enableElementRecord If current element will be recorded and maintained by toolkit. If not set, use this.enableElementRecordGlobal
     */
    createElement(doc: Document, tagName: string, namespace?: "html" | "svg" | "xul", enableElementRecord?: boolean): HTMLElement | XUL.Element | SVGElement | DocumentFragment;
    /**
     * Append element(s) to a node.
     * @param properties See {@link ElementProps}
     * @param container The parent node to append to.
     * @returns A Node that is the appended child (aChild),
     *          except when aChild is a DocumentFragment,
     *          in which case the empty DocumentFragment is returned.
     */
    appendElement(properties: TagElementProps, container: Element): Node;
    /**
     * Inserts a node before a reference node as a child of its parent node.
     * @param properties See {@link ElementProps}
     * @param referenceNode The node before which newNode is inserted.
     * @returns
     */
    insertElementBefore(properties: TagElementProps, referenceNode: Element): Node | undefined;
    /**
     * Replace oldNode with a new one.
     * @param properties See {@link ElementProps}
     * @param oldNode The child to be replaced.
     * @returns The replaced Node. This is the same node as oldChild.
     */
    replaceElement(properties: ElementProps & {
        tag: string;
    }, oldNode: Element): Node | undefined;
    /**
     * Parse XHTML to XUL fragment. For Zotero 6.
     *
     * To load preferences from a Zotero 7's `.xhtml`, use this method to parse it.
     * @param str xhtml raw text
     * @param entities dtd file list ("chrome://xxx.dtd")
     * @param defaultXUL true for default XUL namespace
     */
    parseXHTMLToFragment(str: string, entities?: string[], defaultXUL?: boolean): DocumentFragment;
}
export interface UIOptions extends BasicOptions {
    ui: {
        /**
         * Whether to record elements created with `createElement`.
         */
        enableElementRecord: boolean;
        /**
         * Wether to log the `ElementProps` parameter in `createElement`.
         */
        enableElementJSONLog: boolean;
        /**
         * Wether to log the DOM node mounted by `createElement`.
         */
        enableElementDOMLog: boolean;
    };
}
/**
 * `props` of `UITool.createElement`. See {@link UITool}
 */
export interface ElementProps {
    /**
     * tagName
     */
    tag?: string;
    /**
     * id
     */
    id?: string;
    /**
     * xul | html | svg
     */
    namespace?: string;
    /**
     * classList
     */
    classList?: Array<string>;
    /**
     * styles
     */
    styles?: Partial<CSSStyleDeclaration>;
    /**
     * Set with `elem.prop =`
     */
    properties?: {
        [key: string]: unknown;
    };
    /**
     * @deprecated Use `properties`
     */
    directAttributes?: {
        [key: string]: string | boolean | number | null | undefined;
    };
    /**
     * Set with `elem.setAttribute()`
     */
    attributes?: {
        [key: string]: string | boolean | number | null | undefined;
    };
    /**
     * Event listeners
     *  */
    listeners?: Array<{
        type: string;
        listener: EventListenerOrEventListenerObject | ((e: Event) => void) | null | undefined;
        options?: boolean | AddEventListenerOptions;
    }>;
    /**
     * Child elements. Will be created and appended to this element.
     */
    children?: Array<TagElementProps>;
    /**
     * Set true to check if the element exists using `id`. If exists, return this element and do not do anything.
     */
    ignoreIfExists?: boolean;
    /**
     * Set true to check if the element exists using `id`. If exists, skip element creation and continue with props/attrs/children.
     */
    skipIfExists?: boolean;
    /**
     * Set true to check if the element exists using `id`. If exists, remove and re-create it, then continue with props/attrs/children.
     */
    removeIfExists?: boolean;
    /**
     * Existence check will be processed under this element, default `document`
     */
    checkExistenceParent?: HTMLElement;
    /**
     * Custom check hook. If it returns false, return undefined and do not do anything.
     * @param doc
     * @param options
     */
    customCheck?: (doc: Document, options: ElementProps) => boolean;
    /**
     * @deprecated Use `children`
     */
    subElementOptions?: Array<TagElementProps>;
    /**
     * Enable elements to be recorded by the toolkit so it can be removed when calling `unregisterAll`.
     */
    enableElementRecord?: boolean;
    /**
     * Enable elements to be printed to console & Zotero.debug.
     */
    enableElementJSONLog?: boolean;
    /**
     * Enable elements to be printed to console & Zotero.debug.
     */
    enableElementDOMLog?: boolean;
}
export interface TagElementProps extends ElementProps {
    tag: string;
}
export interface HTMLElementProps extends Exclude<ElementProps, {
    tag: any;
}> {
    namespace?: "html";
}
interface SVGElementProps extends Exclude<ElementProps, {
    tag: any;
}> {
    namespace?: "svg";
}
export interface XULElementProps extends Exclude<ElementProps, {
    tag: any;
}> {
    namespace?: "xul";
}
export interface FragmentElementProps {
    children?: Array<ElementProps>;
}
interface XULElementTagNameMap {
    action: XUL.Element;
    arrowscrollbox: XUL.Element;
    bbox: XUL.Element;
    binding: XUL.Element;
    bindings: XUL.Element;
    box: XUL.Box;
    broadcaster: XUL.Element;
    broadcasterset: XUL.Element;
    button: XUL.Button;
    browser: XUL.Element;
    checkbox: XUL.Checkbox;
    caption: XUL.Element;
    colorpicker: XUL.Element;
    column: XUL.Element;
    columns: XUL.Element;
    commandset: XUL.Element;
    command: XUL.Command;
    conditions: XUL.Element;
    content: XUL.Element;
    deck: XUL.Deck;
    description: XUL.Description;
    dialog: XUL.Element;
    dialogheader: XUL.Element;
    editor: XUL.Element;
    grid: XUL.Element;
    grippy: XUL.Grippy;
    groupbox: XUL.GroupBox;
    hbox: XUL.Box;
    iframe: XUL.Element;
    image: XUL.Element;
    key: XUL.Element;
    keyset: XUL.Element;
    label: XUL.Label;
    listbox: XUL.Element;
    listcell: XUL.Element;
    listcol: XUL.Element;
    listcols: XUL.Element;
    listhead: XUL.Element;
    listheader: XUL.Element;
    listitem: XUL.ListItem;
    member: XUL.Element;
    menu: XUL.Menu;
    menubar: XUL.MenuBar;
    menuitem: XUL.MenuItem;
    menulist: XUL.MenuList;
    menupopup: XUL.MenuPopup;
    menuseparator: XUL.MenuSeparator;
    observes: XUL.Element;
    overlay: XUL.Element;
    page: XUL.Element;
    popup: XUL.Popup;
    popupset: XUL.Element;
    preference: XUL.Element;
    preferences: XUL.Element;
    prefpane: XUL.Element;
    prefwindow: XUL.Element;
    progressmeter: XUL.Element;
    radio: XUL.Radio;
    radiogroup: XUL.RadioGroup;
    resizer: XUL.Element;
    richlistbox: XUL.Element;
    richlistitem: XUL.Element;
    row: XUL.Element;
    rows: XUL.Element;
    rule: XUL.Element;
    script: XUL.Element;
    scrollbar: XUL.ScrollBar;
    scrollbox: XUL.Element;
    scrollcorner: XUL.Element;
    separator: XUL.Separator;
    spacer: XUL.Spacer;
    splitter: XUL.Splitter;
    stack: XUL.Element;
    statusbar: XUL.StatusBar;
    statusbarpanel: XUL.StatusBarPanel;
    stringbundle: XUL.Element;
    stringbundleset: XUL.Element;
    tab: XUL.Tab;
    tabbrowser: XUL.Element;
    tabbox: XUL.TabBox;
    tabpanel: XUL.TabPanel;
    tabpanels: XUL.TabPanels;
    tabs: XUL.Tabs;
    template: XUL.Element;
    textnode: XUL.Element;
    textbox: XUL.Textbox;
    titlebar: XUL.Element;
    toolbar: XUL.ToolBar;
    toolbarbutton: XUL.ToolBarButton;
    toolbargrippy: XUL.ToolBarGrippy;
    toolbaritem: XUL.ToolBarItem;
    toolbarpalette: XUL.ToolBarPalette;
    toolbarseparator: XUL.ToolBarSeparator;
    toolbarset: XUL.ToolBarSet;
    toolbarspacer: XUL.ToolBarSpacer;
    toolbarspring: XUL.ToolBarSpring;
    toolbox: XUL.ToolBox;
    tooltip: XUL.Tooltip;
    tree: XUL.Tree;
    treecell: XUL.TreeCell;
    treechildren: XUL.TreeChildren;
    treecol: XUL.TreeCol;
    treecols: XUL.TreeCols;
    treeitem: XUL.TreeItem;
    treerow: XUL.TreeRow;
    treeseparator: XUL.TreeSeparator;
    triple: XUL.Element;
    vbox: XUL.Box;
    window: XUL.Element;
    wizard: XUL.Element;
    wizardpage: XUL.Element;
}
export {};
//# sourceMappingURL=ui.d.ts.map