"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReaderTool = void 0;
const basic_1 = require("../basic");
const wait_1 = require("../utils/wait");
/**
 * Zotero ReaderInstance APIs.
 */
class ReaderTool extends basic_1.BasicTool {
    /**
     * Get the selected tab reader.
     * @param waitTime Wait for n MS until the reader is ready
     */
    async getReader(waitTime = 5000) {
        const Zotero_Tabs = this.getGlobal("Zotero_Tabs");
        if (Zotero_Tabs.selectedType !== "reader") {
            return undefined;
        }
        let reader = Zotero.Reader.getByTabID(Zotero_Tabs.selectedID);
        let delayCount = 0;
        const checkPeriod = 50;
        while (!reader && delayCount * checkPeriod < waitTime) {
            await Zotero.Promise.delay(checkPeriod);
            reader = Zotero.Reader.getByTabID(Zotero_Tabs.selectedID);
            delayCount++;
        }
        await (reader === null || reader === void 0 ? void 0 : reader._initPromise);
        return reader;
    }
    /**
     * Get all window readers.
     */
    getWindowReader() {
        const Zotero_Tabs = this.getGlobal("Zotero_Tabs");
        let windowReaders = [];
        let tabs = Zotero_Tabs._tabs.map((e) => e.id);
        for (let i = 0; i < Zotero.Reader._readers.length; i++) {
            let flag = false;
            for (let j = 0; j < tabs.length; j++) {
                if (Zotero.Reader._readers[i].tabID == tabs[j]) {
                    flag = true;
                    break;
                }
            }
            if (!flag) {
                windowReaders.push(Zotero.Reader._readers[i]);
            }
        }
        return windowReaders;
    }
    /**
     * Get Reader tabpanel deck element.
     * @deprecated - use item pane api
     * @alpha
     */
    getReaderTabPanelDeck() {
        var _a;
        const deck = (_a = this.getGlobal("window").document.querySelector(".notes-pane-deck")) === null || _a === void 0 ? void 0 : _a.previousElementSibling;
        return deck;
    }
    /**
     * Add a reader tabpanel deck selection change observer.
     * @deprecated - use item pane api
     * @alpha
     * @param callback
     */
    async addReaderTabPanelDeckObserver(callback) {
        await (0, wait_1.waitUtilAsync)(() => !!this.getReaderTabPanelDeck());
        const deck = this.getReaderTabPanelDeck();
        const observer = new (this.getGlobal("MutationObserver"))(async (mutations) => {
            mutations.forEach(async (mutation) => {
                const target = mutation.target;
                // When the tabbox is ready, the selectedIndex of tabbox is changed.
                // When reader tab is changed, the selectedIndex of deck is changed.
                if (target.classList.contains("zotero-view-tabbox") ||
                    target.tagName === "deck") {
                    callback();
                }
            });
        });
        observer.observe(deck, {
            attributes: true,
            attributeFilter: ["selectedIndex"],
            subtree: true,
        });
        return observer;
    }
    /**
     * Get the selected annotation data.
     * @param reader Target reader
     * @returns The selected annotation data.
     */
    getSelectedAnnotationData(reader) {
        var _a;
        const annotation = 
        // @ts-ignore
        (_a = reader === null || reader === void 0 ? void 0 : reader._internalReader._lastView._selectionPopup) === null || _a === void 0 ? void 0 : _a.annotation;
        return annotation;
    }
    /**
     * Get the text selection of reader.
     * @param reader Target reader
     * @returns The text selection of reader.
     */
    getSelectedText(reader) {
        var _a, _b;
        return (_b = (_a = this.getSelectedAnnotationData(reader)) === null || _a === void 0 ? void 0 : _a.text) !== null && _b !== void 0 ? _b : "";
    }
}
exports.ReaderTool = ReaderTool;
//# sourceMappingURL=reader.js.map